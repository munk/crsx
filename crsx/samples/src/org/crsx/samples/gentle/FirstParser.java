/* Generated By:JavaCC: Do not edit this line. FirstParser.java */
package org.crsx.samples.gentle;

/** PG Grammar for HACS module org.crsx.samples.gentle.First.
 * @version $Id: CookPG.crs,v 1.48 2014/01/26 21:14:39 krisrose Exp $
 */
public class FirstParser implements net.sf.crsx.Parser, FirstParserConstants {
        /** Factory. */
        net.sf.crsx.Factory<? extends net.sf.crsx.Term> factory;
        /** Compilation unit name for error messages. */
        String unit;
        /** Whether the parser should capture token locations. */
        boolean captureLocations = true;
        /** Constructor with token location information. */
        private net.sf.crsx.Constructor makeTConstructor(net.sf.crsx.Sink sink, Token t, Object object, String sort)
        {
                net.sf.crsx.Constructor c = sort == null ? sink.makeConstructor(object) : sink.makeLiteral(object, sort);
                if (t == null) t = token;
                if (captureLocations && t != null)
                {
                        if (factory.get("meta") == null)
                                c = net.sf.crsx.util.Util.wrapWithLocation(sink, c, unit, t.beginLine, t.beginColumn);
                }
                return c;
        }

        /** Helper interface with category non-terminal calls. */
        abstract class CategoryCall { abstract net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException; }
        /** Direct category invocations. */
        java.util.Map<String,CategoryCall> categoryCall = new java.util.HashMap<String,CategoryCall>();
        {
                categoryCall.put("first", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_A_Arg$WithEOF(sink, bound);} });
                categoryCall.put("firstA_Arg", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_A_Arg$WithEOF(sink, bound);} });
                categoryCall.put("firstTmp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Tmp$WithEOF(sink, bound);} });
                categoryCall.put("firstI_Instr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_I_Instr$WithEOF(sink, bound);} });
                categoryCall.put("firstA_Progr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_A_Progr$WithEOF(sink, bound);} });
                categoryCall.put("firstStat", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Stat$WithEOF(sink, bound);} });
                categoryCall.put("firstExp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Exp$WithEOF(sink, bound);} });
                categoryCall.put("firstName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Name$WithEOF(sink, bound);} });
                categoryCall.put("firstI_Progr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_I_Progr$WithEOF(sink, bound);} });
                categoryCall.put("firstA_Instr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_A_Instr$WithEOF(sink, bound);} });
                categoryCall.put("firstI_Arg", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_I_Arg$WithEOF(sink, bound);} });
                categoryCall.put("firstRawTerm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawTerm$WithEOF(sink, bound);} });
                categoryCall.put("firstRawTerms", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawTerms$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSortedTerm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSortedTerm$WithEOF(sink, bound);} });
                categoryCall.put("firstRawConstruction", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawConstruction$WithEOF(sink, bound);} });
                categoryCall.put("firstRawVariableUse", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawVariableUse$WithEOF(sink, bound);} });
                categoryCall.put("firstRawMetaApplication", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawMetaApplication$WithEOF(sink, bound);} });
                categoryCall.put("firstRawScope", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawScope$WithEOF(sink, bound);} });
                categoryCall.put("firstRawScopes", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawScopes$WithEOF(sink, bound);} });
                categoryCall.put("firstRawVariables", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawVariables$WithEOF(sink, bound);} });
                categoryCall.put("firstRaw_A_Arg", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Raw_A_Arg$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSorted_A_Arg", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSorted_A_Arg$WithEOF(sink, bound);} });
                categoryCall.put("firstRawPresorted_A_Arg", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawPresorted_A_Arg$WithEOF(sink, bound);} });
                categoryCall.put("firstRaw_Tmp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Raw_Tmp$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSorted_Tmp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSorted_Tmp$WithEOF(sink, bound);} });
                categoryCall.put("firstRawPresorted_Tmp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawPresorted_Tmp$WithEOF(sink, bound);} });
                categoryCall.put("firstRaw_I_Instr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Raw_I_Instr$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSorted_I_Instr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSorted_I_Instr$WithEOF(sink, bound);} });
                categoryCall.put("firstRawPresorted_I_Instr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawPresorted_I_Instr$WithEOF(sink, bound);} });
                categoryCall.put("firstRaw_A_Progr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Raw_A_Progr$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSorted_A_Progr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSorted_A_Progr$WithEOF(sink, bound);} });
                categoryCall.put("firstRawPresorted_A_Progr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawPresorted_A_Progr$WithEOF(sink, bound);} });
                categoryCall.put("firstRaw_Stat", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Raw_Stat$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSorted_Stat", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSorted_Stat$WithEOF(sink, bound);} });
                categoryCall.put("firstRawPresorted_Stat", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawPresorted_Stat$WithEOF(sink, bound);} });
                categoryCall.put("firstRaw_Exp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Raw_Exp$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSorted_Exp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSorted_Exp$WithEOF(sink, bound);} });
                categoryCall.put("firstRawPresorted_Exp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawPresorted_Exp$WithEOF(sink, bound);} });
                categoryCall.put("firstRaw_Name", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Raw_Name$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSorted_Name", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSorted_Name$WithEOF(sink, bound);} });
                categoryCall.put("firstRawPresorted_Name", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawPresorted_Name$WithEOF(sink, bound);} });
                categoryCall.put("firstRaw_I_Progr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Raw_I_Progr$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSorted_I_Progr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSorted_I_Progr$WithEOF(sink, bound);} });
                categoryCall.put("firstRawPresorted_I_Progr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawPresorted_I_Progr$WithEOF(sink, bound);} });
                categoryCall.put("firstRaw_A_Instr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Raw_A_Instr$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSorted_A_Instr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSorted_A_Instr$WithEOF(sink, bound);} });
                categoryCall.put("firstRawPresorted_A_Instr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawPresorted_A_Instr$WithEOF(sink, bound);} });
                categoryCall.put("firstRaw_Type", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Raw_Type$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSorted_Type", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSorted_Type$WithEOF(sink, bound);} });
                categoryCall.put("firstRawPresorted_Type", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawPresorted_Type$WithEOF(sink, bound);} });
                categoryCall.put("firstRaw_I_Arg", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Raw_I_Arg$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSorted_I_Arg", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSorted_I_Arg$WithEOF(sink, bound);} });
                categoryCall.put("firstRawPresorted_I_Arg", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawPresorted_I_Arg$WithEOF(sink, bound);} });
                categoryCall.put("firstRaw_ID", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Raw_ID$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSorted_ID", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSorted_ID$WithEOF(sink, bound);} });
                categoryCall.put("firstRawPresorted_ID", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawPresorted_ID$WithEOF(sink, bound);} });
                categoryCall.put("firstRaw_INT", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Raw_INT$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSorted_INT", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSorted_INT$WithEOF(sink, bound);} });
                categoryCall.put("firstRawPresorted_INT", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawPresorted_INT$WithEOF(sink, bound);} });
                categoryCall.put("firstRaw_FLOAT", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Raw_FLOAT$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSorted_FLOAT", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSorted_FLOAT$WithEOF(sink, bound);} });
                categoryCall.put("firstRawPresorted_FLOAT", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawPresorted_FLOAT$WithEOF(sink, bound);} });
                categoryCall.put("firstRaw_T", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Raw_T$WithEOF(sink, bound);} });
                categoryCall.put("firstRawSorted_T", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawSorted_T$WithEOF(sink, bound);} });
                categoryCall.put("firstRawPresorted_T", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RawPresorted_T$WithEOF(sink, bound);} });
        }

        // Constructor.

        /** Construct dummy instance. */
        public FirstParser()
        {
                this((java.io.Reader) null);
                disable_tracing();
        }

        // Parser implementation.

        public net.sf.crsx.Parser parser(net.sf.crsx.Factory<? extends net.sf.crsx.Term> f)
        {
                if (factory != null)
                {
                        net.sf.crsx.Parser parser = new FirstParser().parser(f);
                        parser.setParserVerbose(trace_enabled); parser.setParserLocation(captureLocations);
                        return parser;
                }
                else
                {
                        factory = f;
                        assert f != null : "Or Else!";
                        return this;
                }
        }

        public void setParserVerbose(boolean verbose)
        {
                if (verbose)
                        enable_tracing();
                else
                        disable_tracing();
        }

        public void setParserLocation(boolean capture)
        {
                captureLocations = capture;
        }

        public void setEmbeddedParser(net.sf.crsx.Parser subparser) throws net.sf.crsx.CRSException
        {}

        public Iterable<String> categories()
        {
                return categoryCall.keySet();
        }

        public net.sf.crsx.Sink parse(net.sf.crsx.Sink sink, String category, java.io.Reader reader, String unit, int firstLine, int firstColumn, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
        {
                try
                {
                        this.unit = unit;
                        ReInit((java.io.Reader) null);
                        jj_input_stream.ReInit(reader, firstLine, firstColumn); token_source = new FirstParserTokenManager(jj_input_stream); // hacks to update line and column numbers
                        if (bound == null) bound = new net.sf.crsx.util.LinkedExtensibleMap<String, net.sf.crsx.Variable>();
                        if (category == null || category.length() == 0) return N_A_Arg(sink, bound);
                        else if (categoryCall.containsKey(category)) return categoryCall.get(category).call(sink, bound);
                        else throw new net.sf.crsx.CRSException("Parser category '"+category+"' not supported!");
                }
                catch (ParseException e)
                {
                        throw new net.sf.crsx.CRSException(e.getMessage());
                }
        }

        public net.sf.crsx.Term parseTerm(net.sf.crsx.Maker maker, String category, java.io.Reader reader, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
        {
                net.sf.crsx.util.Buffer buffer = new net.sf.crsx.util.Buffer(maker);
                factory.parse(buffer.sink(), category, reader, null, 1, 1, bound);
                return buffer.term(true);
        }

        public net.sf.crsx.Term parseTerm(net.sf.crsx.Maker maker, String category, java.io.Reader reader, String unit, int line, int col, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
        {
                net.sf.crsx.util.Buffer buffer = new net.sf.crsx.util.Buffer(maker);
                factory.parse(buffer.sink(), category, reader, unit, line, col, bound);
                return buffer.term(true);
        }


static String unmeta(String s) {return s.substring(1, s.length()-1).trim();}

        /**
	 * Run the parser and print the resulting term.
	 * @param args should contain two strings: the category and an input file name
	 */
        public static void main(String[] args)
        {
                try
                {
                        if (args.length != 2)
                        {
                                System.err.println("Usage: FirstParser category input");
                                System.exit(2);
                        }
                        String category = args[0];
                        java.io.Reader reader = new java.io.FileReader(args[1]);
                        net.sf.crsx.Factory<net.sf.crsx.generic.GenericTerm> factory = new net.sf.crsx.generic.GenericFactory();
                        net.sf.crsx.Parser parser = new FirstParser();
                        net.sf.crsx.Sink sink = factory.sink(System.out);
                        parser.parser(factory).parse(sink, category, reader, null, 1, 1, null);
                }
                catch (net.sf.crsx.CRSException e)
                {
                        System.err.println("CRS error: "+e);
                        System.exit(1);
                }
                catch (java.io.IOException e)
                {
                        System.err.println("I/O error: "+e);
                        System.exit(1);
                }
        }

/* GRAMMAR. */

/* Productions for INT token. */

/**
 * <em>INT</em> ::=   <a href="#T_meta1_T_M_INT">meta1_T_M_INT</a><font color="red">:unmeta</font>  <br>
 *  |   <a href="#T_meta2_T_M_INT">meta2_T_M_INT</a><font color="red">$$:unmeta:{firstRawSorted_INT}</font>  <br>
 *  |   <a href="#T_T_M_INT">T_M_INT</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_INT(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_INT");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_INT:
        t = jj_consume_token(T_meta1_T_M_INT);
                sink = sink .start(makeTConstructor(sink, t, unmeta(t.toString()), null)) ;
                {if (true) return sink .end() ;}
        break;
      case T_meta2_T_M_INT:
        t = jj_consume_token(T_meta2_T_M_INT);
                try {sink = factory.parser(factory).parse(sink, "firstRawSorted_INT", new java.io.StringReader(unmeta(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_T_M_INT:
        t = jj_consume_token(T_T_M_INT);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_INT");
    }
  }

/* Raw terms of INT token sort. */

/** <em>Raw_INT$WithEOF</em> ::= <em>Raw_INT</em> EOF . */
  final public net.sf.crsx.Sink N_Raw_INT$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_INT$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_Raw_INT(sink, env);
                                                                                                        token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                   {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_INT$WithEOF");
    }
  }

/**
 * <em>Raw_INT</em> ::=  (   <a href="#T_RAW_TOKEN_INT">RAW_TOKEN_INT</a>  )?   <a href="#N_RawPresorted_INT">&lang;RawPresorted_INT&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Raw_INT(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_INT");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_INT:
        jj_consume_token(T_RAW_TOKEN_INT);
        break;
      default:
        jj_la1[1] = jj_gen;
        ;
      }
      sink = N_RawPresorted_INT(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_INT");
    }
  }

/** <em>RawSorted_INT$WithEOF</em> ::= <em>RawSorted_INT</em> EOF . */
  final public net.sf.crsx.Sink N_RawSorted_INT$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_INT$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSorted_INT(sink, env);
                                                                                                              token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_INT$WithEOF");
    }
  }

/**
 * <em>RawSorted_INT</em> ::=   <a href="#T_RAW_TOKEN_INT">RAW_TOKEN_INT</a>   <a href="#N_RawPresorted_INT">&lang;RawPresorted_INT&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSorted_INT(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_INT");
    try {
        Token t = null;
      jj_consume_token(T_RAW_TOKEN_INT);
      sink = N_RawPresorted_INT(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_INT");
    }
  }

/** <em>RawPresorted_INT$WithEOF</em> ::= <em>RawPresorted_INT</em> EOF . */
  final public net.sf.crsx.Sink N_RawPresorted_INT$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_INT$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawPresorted_INT(sink, env);
                                                                                                                 token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                            {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_INT$WithEOF");
    }
  }

/**
 * <em>RawPresorted_INT</em> ::=  <font color="red">{RAW-VariableUseSorted}</font>   (  <font color="red">{INT}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-MetaApplicationSorted}</font>   (  <font color="red">{INT}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawPresorted_INT(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_INT");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUseSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "INT", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_META_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplicationSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "INT", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        default:
          jj_la1[2] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_INT");
    }
  }

/* Productions for FLOAT token. */

/**
 * <em>FLOAT</em> ::=   <a href="#T_meta1_T_M_FLOAT">meta1_T_M_FLOAT</a><font color="red">:unmeta</font>  <br>
 *  |   <a href="#T_meta2_T_M_FLOAT">meta2_T_M_FLOAT</a><font color="red">$$:unmeta:{firstRawSorted_FLOAT}</font>  <br>
 *  |   <a href="#T_T_M_FLOAT">T_M_FLOAT</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_FLOAT(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_FLOAT");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_FLOAT:
        t = jj_consume_token(T_meta1_T_M_FLOAT);
                sink = sink .start(makeTConstructor(sink, t, unmeta(t.toString()), null)) ;
                {if (true) return sink .end() ;}
        break;
      case T_meta2_T_M_FLOAT:
        t = jj_consume_token(T_meta2_T_M_FLOAT);
                try {sink = factory.parser(factory).parse(sink, "firstRawSorted_FLOAT", new java.io.StringReader(unmeta(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_T_M_FLOAT:
        t = jj_consume_token(T_T_M_FLOAT);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_FLOAT");
    }
  }

/* Raw terms of FLOAT token sort. */

/** <em>Raw_FLOAT$WithEOF</em> ::= <em>Raw_FLOAT</em> EOF . */
  final public net.sf.crsx.Sink N_Raw_FLOAT$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_FLOAT$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_Raw_FLOAT(sink, env);
                                                                                                          token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_FLOAT$WithEOF");
    }
  }

/**
 * <em>Raw_FLOAT</em> ::=  (   <a href="#T_RAW_TOKEN_FLOAT">RAW_TOKEN_FLOAT</a>  )?   <a href="#N_RawPresorted_FLOAT">&lang;RawPresorted_FLOAT&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Raw_FLOAT(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_FLOAT");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_FLOAT:
        jj_consume_token(T_RAW_TOKEN_FLOAT);
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      sink = N_RawPresorted_FLOAT(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_FLOAT");
    }
  }

/** <em>RawSorted_FLOAT$WithEOF</em> ::= <em>RawSorted_FLOAT</em> EOF . */
  final public net.sf.crsx.Sink N_RawSorted_FLOAT$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_FLOAT$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSorted_FLOAT(sink, env);
                                                                                                                token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                           {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_FLOAT$WithEOF");
    }
  }

/**
 * <em>RawSorted_FLOAT</em> ::=   <a href="#T_RAW_TOKEN_FLOAT">RAW_TOKEN_FLOAT</a>   <a href="#N_RawPresorted_FLOAT">&lang;RawPresorted_FLOAT&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSorted_FLOAT(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_FLOAT");
    try {
        Token t = null;
      jj_consume_token(T_RAW_TOKEN_FLOAT);
      sink = N_RawPresorted_FLOAT(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_FLOAT");
    }
  }

/** <em>RawPresorted_FLOAT$WithEOF</em> ::= <em>RawPresorted_FLOAT</em> EOF . */
  final public net.sf.crsx.Sink N_RawPresorted_FLOAT$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_FLOAT$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawPresorted_FLOAT(sink, env);
                                                                                                                   token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                              {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_FLOAT$WithEOF");
    }
  }

/**
 * <em>RawPresorted_FLOAT</em> ::=  <font color="red">{RAW-VariableUseSorted}</font>   (  <font color="red">{FLOAT}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-MetaApplicationSorted}</font>   (  <font color="red">{FLOAT}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawPresorted_FLOAT(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_FLOAT");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUseSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "FLOAT", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_META_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplicationSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "FLOAT", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        default:
          jj_la1[6] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_FLOAT");
    }
  }

/* Productions for ID token. */

/**
 * <em>ID</em> ::=   <a href="#T_meta1_T_M_ID">meta1_T_M_ID</a><font color="red">:unmeta</font>  <br>
 *  |   <a href="#T_meta2_T_M_ID">meta2_T_M_ID</a><font color="red">$$:unmeta:{firstRawSorted_ID}</font>  <br>
 *  |   <a href="#T_T_M_ID">T_M_ID</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_ID(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_ID");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_ID:
        t = jj_consume_token(T_meta1_T_M_ID);
                sink = sink .start(makeTConstructor(sink, t, unmeta(t.toString()), null)) ;
                {if (true) return sink .end() ;}
        break;
      case T_meta2_T_M_ID:
        t = jj_consume_token(T_meta2_T_M_ID);
                try {sink = factory.parser(factory).parse(sink, "firstRawSorted_ID", new java.io.StringReader(unmeta(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_T_M_ID:
        t = jj_consume_token(T_T_M_ID);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_ID");
    }
  }

/* Raw terms of ID token sort. */

/** <em>Raw_ID$WithEOF</em> ::= <em>Raw_ID</em> EOF . */
  final public net.sf.crsx.Sink N_Raw_ID$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_ID$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_Raw_ID(sink, env);
                                                                                                       token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                  {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_ID$WithEOF");
    }
  }

/**
 * <em>Raw_ID</em> ::=  (   <a href="#T_RAW_TOKEN_ID">RAW_TOKEN_ID</a>  )?   <a href="#N_RawPresorted_ID">&lang;RawPresorted_ID&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Raw_ID(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_ID");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_ID:
        jj_consume_token(T_RAW_TOKEN_ID);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      sink = N_RawPresorted_ID(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_ID");
    }
  }

/** <em>RawSorted_ID$WithEOF</em> ::= <em>RawSorted_ID</em> EOF . */
  final public net.sf.crsx.Sink N_RawSorted_ID$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_ID$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSorted_ID(sink, env);
                                                                                                             token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                        {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_ID$WithEOF");
    }
  }

/**
 * <em>RawSorted_ID</em> ::=   <a href="#T_RAW_TOKEN_ID">RAW_TOKEN_ID</a>   <a href="#N_RawPresorted_ID">&lang;RawPresorted_ID&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSorted_ID(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_ID");
    try {
        Token t = null;
      jj_consume_token(T_RAW_TOKEN_ID);
      sink = N_RawPresorted_ID(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_ID");
    }
  }

/** <em>RawPresorted_ID$WithEOF</em> ::= <em>RawPresorted_ID</em> EOF . */
  final public net.sf.crsx.Sink N_RawPresorted_ID$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_ID$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawPresorted_ID(sink, env);
                                                                                                                token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                           {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_ID$WithEOF");
    }
  }

/**
 * <em>RawPresorted_ID</em> ::=  <font color="red">{RAW-VariableUseSorted}</font>   (  <font color="red">{ID}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-MetaApplicationSorted}</font>   (  <font color="red">{ID}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawPresorted_ID(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_ID");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUseSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "ID", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_META_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplicationSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "ID", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        default:
          jj_la1[10] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_ID");
    }
  }

/* Productions for Exp sort with precedence 0. */

/** <em>Exp$WithEOF</em> ::= <em>Exp</em> EOF . */
  final public net.sf.crsx.Sink N_Exp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp$WithEOF");
    try {
  int savedState = token_source.curLexState;
      sink = N_Exp(sink, env);
                                                                      token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                 {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp$WithEOF");
    }
  }

/**
 * <em>Exp</em> ::=  (   "<code>TA</code>"   <a href="#N_Exp">&lang;Exp&rang;</a> <font color="red">:#_Exp_1</font>   <font color="red">{{ Exp__M_TA_Exp[#_Exp_1]}}</font>  |  <a href="#N_Exp1">&lang;Exp1&rang;</a> <font color="red">:#_Exp_1</font>   <font color="red">{{#_Exp_1}}</font>  ) 
 */
  final public net.sf.crsx.Sink N_Exp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp");
    try {
        Token t = null;
        net.sf.crsx.Sink bs___Exp_1 = null;
        net.sf.crsx.util.Buffer b___Exp_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 22:
        jj_consume_token(22);
                        bs___Exp_1 = b___Exp_1.sink();
        N_Exp(bs___Exp_1, env);
                        sink = sink .start(sink.makeConstructor("Exp__M_TA_Exp")) .copy(b___Exp_1, true) .end() ;
        break;
      case T_meta1_T_M_INT:
      case T_meta2_T_M_INT:
      case T_meta1_T_M_FLOAT:
      case T_meta2_T_M_FLOAT:
      case T_meta1_T_M_ID:
      case T_meta2_T_M_ID:
      case 25:
      case T_meta1_T_M_Exp:
      case T_meta2_T_M_Exp:
      case T_meta1_T_M_Name:
      case T_meta2_T_M_Name:
      case T_T_M_INT:
      case T_T_M_FLOAT:
      case T_T_M_ID:
                        bs___Exp_1 = b___Exp_1.sink();
        N_Exp1(bs___Exp_1, env);
                        sink = sink .copy(b___Exp_1, true) ;
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp");
    }
  }

/* Productions for Exp sort with precedence 1. */

/* Handle left recursion. */

/**
 * <em>Exp1LR</em> ::=   "<code>+</code>"   <a href="#N_Exp2">&lang;Exp2&rang;</a> <font color="red">:#_Exp_2</font>   <a href="#N_Exp1LR">&lang;Exp1LR {{Exp1_LR__M__2b_Exp[#1, #_Exp_2]}}&rang;</a>   <br>
 *  |  <font color="red">{{#1}}</font> 
 */
  final public net.sf.crsx.Sink N_Exp1LR(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env, net.sf.crsx.util.Buffer b__1) throws ParseException {
    trace_call("N_Exp1LR");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Exp_2 = null;
        net.sf.crsx.util.Buffer b___Exp_2 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 23:
        jj_consume_token(23);
                bs___Exp_2 = b___Exp_2.sink();
        N_Exp2(bs___Exp_2, env);
                s1 = b1.sink();
                s1 .start(s1.makeConstructor("Exp1_LR__M__2b_Exp")) .copy(b__1, false) .copy(b___Exp_2, true) .end() ;
        sink = N_Exp1LR(sink, env, b1);
         {if (true) return sink;}
        break;
      default:
        jj_la1[13] = jj_gen;
                sink = sink .copy(b__1, false) ;
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp1LR");
    }
  }

/**
 * <em>Exp1</em> ::=  <a href="#N_Exp2">&lang;Exp2&rang;</a> <font color="red">:#_Exp_1</font>   <a href="#N_Exp1LR">&lang;Exp1LR {{#_Exp_1}}&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Exp1(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp1");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Exp_1 = null;
        net.sf.crsx.util.Buffer b___Exp_1 = new net.sf.crsx.util.Buffer(sink);
                bs___Exp_1 = b___Exp_1.sink();
      N_Exp2(bs___Exp_1, env);
                s1 = b1.sink();
                s1 .copy(b___Exp_1, true) ;
      sink = N_Exp1LR(sink, env, b1);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp1");
    }
  }

/* Productions for Exp sort with precedence 2. */

/* Handle left recursion. */

/**
 * <em>Exp2LR</em> ::=   "<code>*</code>"   <a href="#N_Exp3">&lang;Exp3&rang;</a> <font color="red">:#_Exp_2</font>   <a href="#N_Exp2LR">&lang;Exp2LR {{Exp2_LR__M__2a_Exp[#1, #_Exp_2]}}&rang;</a>   <br>
 *  |  <font color="red">{{#1}}</font> 
 */
  final public net.sf.crsx.Sink N_Exp2LR(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env, net.sf.crsx.util.Buffer b__1) throws ParseException {
    trace_call("N_Exp2LR");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Exp_2 = null;
        net.sf.crsx.util.Buffer b___Exp_2 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 24:
        jj_consume_token(24);
                bs___Exp_2 = b___Exp_2.sink();
        N_Exp3(bs___Exp_2, env);
                s1 = b1.sink();
                s1 .start(s1.makeConstructor("Exp2_LR__M__2a_Exp")) .copy(b__1, false) .copy(b___Exp_2, true) .end() ;
        sink = N_Exp2LR(sink, env, b1);
         {if (true) return sink;}
        break;
      default:
        jj_la1[14] = jj_gen;
                sink = sink .copy(b__1, false) ;
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp2LR");
    }
  }

/**
 * <em>Exp2</em> ::=  <a href="#N_Exp3">&lang;Exp3&rang;</a> <font color="red">:#_Exp_1</font>   <a href="#N_Exp2LR">&lang;Exp2LR {{#_Exp_1}}&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Exp2(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp2");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Exp_1 = null;
        net.sf.crsx.util.Buffer b___Exp_1 = new net.sf.crsx.util.Buffer(sink);
                bs___Exp_1 = b___Exp_1.sink();
      N_Exp3(bs___Exp_1, env);
                s1 = b1.sink();
                s1 .copy(b___Exp_1, true) ;
      sink = N_Exp2LR(sink, env, b1);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp2");
    }
  }

/* Productions for Exp sort with (highest) precedence 3. */

/**
 * <em>Exp3</em> ::=   <a href="#T_meta1_T_M_Exp">meta1_T_M_Exp</a><font color="red">:unmeta</font>  <br>
 *  |   <a href="#T_meta2_T_M_Exp">meta2_T_M_Exp</a><font color="red">$$:unmeta:{firstRawSorted_Exp}</font>  <br>
 *  |  (   "<code>(</code>"   <a href="#N_Exp">&lang;Exp&rang;</a> <font color="red">:#</font>    "<code>)</code>"   <font color="red">{{Exp3__M__28_Exp__M__29[#]}}</font>  |  (  <a href="#N_INT">&lang;INT&rang;</a> <font color="red">:#_INT_1</font>   <font color="red">{{Exp3_INT[#_INT_1]}}</font>  |  (  <a href="#N_FLOAT">&lang;FLOAT&rang;</a> <font color="red">:#_FLOAT_1</font>   <font color="red">{{Exp3_FLOAT[#_FLOAT_1]}}</font>  |  <a href="#N_Name">&lang;Name&rang;</a> <font color="red">:#_Name_1</font>   <font color="red">{{Exp3_Name[#_Name_1]}}</font>  )  )  ) 
 */
  final public net.sf.crsx.Sink N_Exp3(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp3");
    try {
        net.sf.crsx.Sink bs___Name_1 = null;
        Token t = null;
        net.sf.crsx.util.Buffer b___Name_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___FLOAT_1 = null;
        net.sf.crsx.util.Buffer b___INT_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs__ = null;
        net.sf.crsx.util.Buffer b___FLOAT_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___INT_1 = null;
        net.sf.crsx.util.Buffer b__ = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_Exp:
        t = jj_consume_token(T_meta1_T_M_Exp);
                sink = sink .start(makeTConstructor(sink, t, unmeta(t.toString()), null)) ;
                {if (true) return sink .end() ;}
        break;
      case T_meta2_T_M_Exp:
        t = jj_consume_token(T_meta2_T_M_Exp);
                try {sink = factory.parser(factory).parse(sink, "firstRawSorted_Exp", new java.io.StringReader(unmeta(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta1_T_M_INT:
      case T_meta2_T_M_INT:
      case T_meta1_T_M_FLOAT:
      case T_meta2_T_M_FLOAT:
      case T_meta1_T_M_ID:
      case T_meta2_T_M_ID:
      case 25:
      case T_meta1_T_M_Name:
      case T_meta2_T_M_Name:
      case T_T_M_INT:
      case T_T_M_FLOAT:
      case T_T_M_ID:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 25:
          jj_consume_token(25);
                        bs__ = b__.sink();
          N_Exp(bs__, env);
          jj_consume_token(26);
                        sink = sink .start(sink.makeConstructor("Exp3__M__28_Exp__M__29")) .copy(b__, true) .end() ;
          break;
        case T_meta1_T_M_INT:
        case T_meta2_T_M_INT:
        case T_meta1_T_M_FLOAT:
        case T_meta2_T_M_FLOAT:
        case T_meta1_T_M_ID:
        case T_meta2_T_M_ID:
        case T_meta1_T_M_Name:
        case T_meta2_T_M_Name:
        case T_T_M_INT:
        case T_T_M_FLOAT:
        case T_T_M_ID:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case T_meta1_T_M_INT:
          case T_meta2_T_M_INT:
          case T_T_M_INT:
                                bs___INT_1 = b___INT_1.sink();
            N_INT(bs___INT_1, env);
                                sink = sink .start(sink.makeConstructor("Exp3_INT")) .copy(b___INT_1, true) .end() ;
            break;
          case T_meta1_T_M_FLOAT:
          case T_meta2_T_M_FLOAT:
          case T_meta1_T_M_ID:
          case T_meta2_T_M_ID:
          case T_meta1_T_M_Name:
          case T_meta2_T_M_Name:
          case T_T_M_FLOAT:
          case T_T_M_ID:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case T_meta1_T_M_FLOAT:
            case T_meta2_T_M_FLOAT:
            case T_T_M_FLOAT:
                                        bs___FLOAT_1 = b___FLOAT_1.sink();
              N_FLOAT(bs___FLOAT_1, env);
                                        sink = sink .start(sink.makeConstructor("Exp3_FLOAT")) .copy(b___FLOAT_1, true) .end() ;
              break;
            case T_meta1_T_M_ID:
            case T_meta2_T_M_ID:
            case T_meta1_T_M_Name:
            case T_meta2_T_M_Name:
            case T_T_M_ID:
                                        bs___Name_1 = b___Name_1.sink();
              N_Name(bs___Name_1, env);
                                        sink = sink .start(sink.makeConstructor("Exp3_Name")) .copy(b___Name_1, true) .end() ;
              break;
            default:
              jj_la1[15] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[16] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp3");
    }
  }

/* Raw terms of Exp production sort. */

/** <em>Raw_Exp$WithEOF</em> ::= <em>Raw_Exp</em> EOF . */
  final public net.sf.crsx.Sink N_Raw_Exp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_Exp$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_Raw_Exp(sink, env);
                                                                                                        token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                   {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_Exp$WithEOF");
    }
  }

/**
 * <em>Raw_Exp</em> ::=  (   <a href="#T_RAW_TOKEN_Exp">RAW_TOKEN_Exp</a>  )?   <a href="#N_RawPresorted_Exp">&lang;RawPresorted_Exp&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Raw_Exp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_Exp");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_Exp:
        jj_consume_token(T_RAW_TOKEN_Exp);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      sink = N_RawPresorted_Exp(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_Exp");
    }
  }

/** <em>RawSorted_Exp$WithEOF</em> ::= <em>RawSorted_Exp</em> EOF . */
  final public net.sf.crsx.Sink N_RawSorted_Exp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_Exp$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSorted_Exp(sink, env);
                                                                                                              token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_Exp$WithEOF");
    }
  }

/**
 * <em>RawSorted_Exp</em> ::=   <a href="#T_RAW_TOKEN_Exp">RAW_TOKEN_Exp</a>   <a href="#N_RawPresorted_Exp">&lang;RawPresorted_Exp&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSorted_Exp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_Exp");
    try {
        Token t = null;
      jj_consume_token(T_RAW_TOKEN_Exp);
      sink = N_RawPresorted_Exp(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_Exp");
    }
  }

/** <em>RawPresorted_Exp$WithEOF</em> ::= <em>RawPresorted_Exp</em> EOF . */
  final public net.sf.crsx.Sink N_RawPresorted_Exp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_Exp$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawPresorted_Exp(sink, env);
                                                                                                                 token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                            {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_Exp$WithEOF");
    }
  }

/**
 * <em>RawPresorted_Exp</em> ::=  <font color="red">{RAW-VariableUseSorted}</font>   (  <font color="red">{Exp}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-MetaApplicationSorted}</font>   (  <font color="red">{Exp}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-ConstructionSorted}</font>   (  <font color="red">{Exp}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_CONSTRUCTOR">RAW_CONSTRUCTOR</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawScopes">&lang;RawScopes&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |   <a href="#T_RAW_LPAREN">RAW_LPAREN</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawPresorted_Exp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_Exp");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUseSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "Exp", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_META_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplicationSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "Exp", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        default:
          jj_la1[20] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_CONSTRUCTOR:
                sink = sink .start(makeTConstructor(sink, t, "RAW-ConstructionSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "Exp", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_CONSTRUCTOR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawScopes(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        case T_RAW_LPAREN:
          jj_consume_token(T_RAW_LPAREN);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RPAREN);
          break;
        default:
          jj_la1[21] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_Exp");
    }
  }

/* Productions for Name sort with (highest) precedence 0. */

/** <em>Name$WithEOF</em> ::= <em>Name</em> EOF . */
  final public net.sf.crsx.Sink N_Name$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Name$WithEOF");
    try {
  int savedState = token_source.curLexState;
      sink = N_Name(sink, env);
                                                                       token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                  {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Name$WithEOF");
    }
  }

/**
 * <em>Name</em> ::=   <a href="#T_meta1_T_M_Name">meta1_T_M_Name</a><font color="red">:unmeta</font>  <br>
 *  |   <a href="#T_meta2_T_M_Name">meta2_T_M_Name</a><font color="red">$$:unmeta:{firstRawSorted_Name}</font>  <br>
 *  |  <a href="#N_ID">&lang;ID&rang;</a> <font color="red">!!!:#_ID_1</font>   <font color="red">{{#_ID_1}}</font> 
 */
  final public net.sf.crsx.Sink N_Name(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Name");
    try {
        net.sf.crsx.Sink bs___ID_1 = null;
        Token t = null;
        String c1 = null;
        String s___ID_1 = null;
        net.sf.crsx.util.Buffer b___ID_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Variable v___ID_1 = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_Name:
        t = jj_consume_token(T_meta1_T_M_Name);
                sink = sink .start(makeTConstructor(sink, t, unmeta(t.toString()), null)) ;
                {if (true) return sink .end() ;}
        break;
      case T_meta2_T_M_Name:
        t = jj_consume_token(T_meta2_T_M_Name);
                try {sink = factory.parser(factory).parse(sink, "firstRawSorted_Name", new java.io.StringReader(unmeta(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta1_T_M_ID:
      case T_meta2_T_M_ID:
      case T_T_M_ID:
                bs___ID_1 = b___ID_1.sink();
        N_ID(bs___ID_1, env);
                c1 = net.sf.crsx.util.Util.symbol(b___ID_1.term(true));
                s___ID_1 = c1;
                v___ID_1 = (env.containsKey(s___ID_1) ? env.get(s___ID_1) : factory.freeVariable(s___ID_1, true, true));
                if (v___ID_1 == null) {if (true) throw new ParseException("Variable "+s___ID_1+" cannot be resolved?");}
                sink = sink .use(v___ID_1) ;
         {if (true) return sink;}
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Name");
    }
  }

/* Raw terms of Name production sort. */

/** <em>Raw_Name$WithEOF</em> ::= <em>Raw_Name</em> EOF . */
  final public net.sf.crsx.Sink N_Raw_Name$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_Name$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_Raw_Name(sink, env);
                                                                                                         token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                    {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_Name$WithEOF");
    }
  }

/**
 * <em>Raw_Name</em> ::=  (   <a href="#T_RAW_TOKEN_Name">RAW_TOKEN_Name</a>  )?   <a href="#N_RawPresorted_Name">&lang;RawPresorted_Name&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Raw_Name(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_Name");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_Name:
        jj_consume_token(T_RAW_TOKEN_Name);
        break;
      default:
        jj_la1[24] = jj_gen;
        ;
      }
      sink = N_RawPresorted_Name(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_Name");
    }
  }

/** <em>RawSorted_Name$WithEOF</em> ::= <em>RawSorted_Name</em> EOF . */
  final public net.sf.crsx.Sink N_RawSorted_Name$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_Name$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSorted_Name(sink, env);
                                                                                                               token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                          {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_Name$WithEOF");
    }
  }

/**
 * <em>RawSorted_Name</em> ::=   <a href="#T_RAW_TOKEN_Name">RAW_TOKEN_Name</a>   <a href="#N_RawPresorted_Name">&lang;RawPresorted_Name&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSorted_Name(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_Name");
    try {
        Token t = null;
      jj_consume_token(T_RAW_TOKEN_Name);
      sink = N_RawPresorted_Name(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_Name");
    }
  }

/** <em>RawPresorted_Name$WithEOF</em> ::= <em>RawPresorted_Name</em> EOF . */
  final public net.sf.crsx.Sink N_RawPresorted_Name$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_Name$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawPresorted_Name(sink, env);
                                                                                                                  token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                             {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_Name$WithEOF");
    }
  }

/**
 * <em>RawPresorted_Name</em> ::=  <font color="red">{RAW-VariableUseSorted}</font>   (  <font color="red">{Name}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-MetaApplicationSorted}</font>   (  <font color="red">{Name}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-ConstructionSorted}</font>   (  <font color="red">{Name}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_CONSTRUCTOR">RAW_CONSTRUCTOR</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawScopes">&lang;RawScopes&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |   <a href="#T_RAW_LPAREN">RAW_LPAREN</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawPresorted_Name(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_Name");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUseSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "Name", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_META_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplicationSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "Name", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        default:
          jj_la1[25] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_CONSTRUCTOR:
                sink = sink .start(makeTConstructor(sink, t, "RAW-ConstructionSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "Name", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_CONSTRUCTOR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawScopes(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        case T_RAW_LPAREN:
          jj_consume_token(T_RAW_LPAREN);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RPAREN);
          break;
        default:
          jj_la1[26] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_Name");
    }
  }

/* Productions for Stat sort with (highest) precedence 0. */

/** <em>Stat$WithEOF</em> ::= <em>Stat</em> EOF . */
  final public net.sf.crsx.Sink N_Stat$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Stat$WithEOF");
    try {
  int savedState = token_source.curLexState;
      sink = N_Stat(sink, env);
                                                                       token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                  {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Stat$WithEOF");
    }
  }

/**
 * <em>Stat</em> ::=   <a href="#T_meta1_T_M_Stat">meta1_T_M_Stat</a><font color="red">:unmeta</font>  <br>
 *  |   <a href="#T_meta2_T_M_Stat">meta2_T_M_Stat</a><font color="red">$$:unmeta:{firstRawSorted_Stat}</font>  <br>
 *  |  (   "<code>TA</code>"    "<code>{</code>"   <a href="#N_Stat">&lang;Stat&rang;</a> <font color="red">:#_Stat_1</font>    "<code>}</code>"   <font color="red">{{ Stat__M_TA__M__7b_Stat__M__7d[#_Stat_1]}}</font>  |  (   "<code>TA2</code>"    "<code>{</code>"   <a href="#N_Stat">&lang;Stat&rang;</a> <font color="red">:#_Stat_1</font>    "<code>}</code>"   <font color="red">{{ Stat__M_TA2__M__7b_Stat__M__7d[#_Stat_1]}}</font>  |  (   "<code>{</code>"   <a href="#N_Stat">&lang;Stat&rang;</a> <font color="red">:#_Stat_1</font>    "<code>}</code>"   <a href="#N_Stat">&lang;Stat&rang;</a> <font color="red">:#_Stat_2</font>   <font color="red">{{Stat__M__7b_Stat__M__7d_Stat[#_Stat_1, #_Stat_2]}}</font>  |  (  <a href="#N_Name">&lang;Name&rang;</a> <font color="red">^x</font>    "<code>:=</code>"   <a href="#N_Exp">&lang;Exp&rang;</a> <font color="red">:#_Exp_1</font>    "<code>;</code>"   <a href="#N_Stat">&lang;Stat&rang;</a> <font color="red">[x]</font><font color="red">:#_Stat_2</font>   <font color="red">{{Stat_vName__M__3a_3d_Exp__M__3b_Stat[#_Exp_1, #_Stat_2]}}</font>  |  <font color="red">{{StatEMPTY}}</font>  )  )  )  ) 
 */
  final public net.sf.crsx.Sink N_Stat(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Stat");
    try {
        net.sf.crsx.Variable v_x = null;
        net.sf.crsx.Sink bs___Stat_1 = null;
        net.sf.crsx.Sink bs___Stat_2 = null;
        Token t = null;
        net.sf.crsx.Sink bs_x = null;
        net.sf.crsx.util.Buffer b_x = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Exp_1 = null;
        String c5 = null;
        net.sf.crsx.util.Buffer b___Stat_1 = new net.sf.crsx.util.Buffer(sink);
        String s_x = null;
        net.sf.crsx.util.Buffer b___Stat_2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___Exp_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_Stat:
        t = jj_consume_token(T_meta1_T_M_Stat);
                sink = sink .start(makeTConstructor(sink, t, unmeta(t.toString()), null)) ;
                {if (true) return sink .end() ;}
        break;
      case T_meta2_T_M_Stat:
        t = jj_consume_token(T_meta2_T_M_Stat);
                try {sink = factory.parser(factory).parse(sink, "firstRawSorted_Stat", new java.io.StringReader(unmeta(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      default:
        jj_la1[32] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 22:
          jj_consume_token(22);
          jj_consume_token(41);
                        bs___Stat_1 = b___Stat_1.sink();
          N_Stat(bs___Stat_1, env);
          jj_consume_token(42);
                        sink = sink .start(sink.makeConstructor("Stat__M_TA__M__7b_Stat__M__7d")) .copy(b___Stat_1, true) .end() ;
          break;
        default:
          jj_la1[31] = jj_gen;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 43:
            jj_consume_token(43);
            jj_consume_token(41);
                                bs___Stat_1 = b___Stat_1.sink();
            N_Stat(bs___Stat_1, env);
            jj_consume_token(42);
                                sink = sink .start(sink.makeConstructor("Stat__M_TA2__M__7b_Stat__M__7d")) .copy(b___Stat_1, true) .end() ;
            break;
          default:
            jj_la1[30] = jj_gen;
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 41:
              jj_consume_token(41);
                                        bs___Stat_1 = b___Stat_1.sink();
              N_Stat(bs___Stat_1, env);
              jj_consume_token(42);
                                        bs___Stat_2 = b___Stat_2.sink();
              N_Stat(bs___Stat_2, env);
                                        sink = sink .start(sink.makeConstructor("Stat__M__7b_Stat__M__7d_Stat")) .copy(b___Stat_1, true) .copy(b___Stat_2, true) .end() ;
              break;
            default:
              jj_la1[29] = jj_gen;
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case T_meta1_T_M_ID:
              case T_meta2_T_M_ID:
              case T_meta1_T_M_Name:
              case T_meta2_T_M_Name:
              case T_T_M_ID:
                                                bs_x = b_x.sink();
                N_Name(bs_x, env);
                                                c5 = net.sf.crsx.util.Util.symbol(b_x.term(true));
                                                s_x = c5;
                                                v_x = sink.makeVariable(s_x,true);
                jj_consume_token(44);
                                                bs___Exp_1 = b___Exp_1.sink();
                N_Exp(bs___Exp_1, env);
                jj_consume_token(45);
                                                bs___Stat_2 = b___Stat_2.sink();
                                                {
                                                        net.sf.crsx.Variable[] bs1 = {v_x};
                                                        bs___Stat_2 = bs___Stat_2.binds(bs1);
                                                }
                N_Stat(bs___Stat_2, env.extend(s_x, v_x));
                                                sink = sink .start(sink.makeConstructor("Stat_vName__M__3a_3d_Exp__M__3b_Stat")) .copy(b___Exp_1, true) .copy(b___Stat_2, true) .end() ;
                break;
              default:
                jj_la1[28] = jj_gen;
                                                sink = sink .start(sink.makeConstructor("StatEMPTY")) .end() ;
              }
            }
          }
        }
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Stat");
    }
  }

/* Raw terms of Stat production sort. */

/** <em>Raw_Stat$WithEOF</em> ::= <em>Raw_Stat</em> EOF . */
  final public net.sf.crsx.Sink N_Raw_Stat$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_Stat$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_Raw_Stat(sink, env);
                                                                                                         token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                    {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_Stat$WithEOF");
    }
  }

/**
 * <em>Raw_Stat</em> ::=  (   <a href="#T_RAW_TOKEN_Stat">RAW_TOKEN_Stat</a>  )?   <a href="#N_RawPresorted_Stat">&lang;RawPresorted_Stat&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Raw_Stat(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_Stat");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_Stat:
        jj_consume_token(T_RAW_TOKEN_Stat);
        break;
      default:
        jj_la1[33] = jj_gen;
        ;
      }
      sink = N_RawPresorted_Stat(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_Stat");
    }
  }

/** <em>RawSorted_Stat$WithEOF</em> ::= <em>RawSorted_Stat</em> EOF . */
  final public net.sf.crsx.Sink N_RawSorted_Stat$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_Stat$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSorted_Stat(sink, env);
                                                                                                               token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                          {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_Stat$WithEOF");
    }
  }

/**
 * <em>RawSorted_Stat</em> ::=   <a href="#T_RAW_TOKEN_Stat">RAW_TOKEN_Stat</a>   <a href="#N_RawPresorted_Stat">&lang;RawPresorted_Stat&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSorted_Stat(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_Stat");
    try {
        Token t = null;
      jj_consume_token(T_RAW_TOKEN_Stat);
      sink = N_RawPresorted_Stat(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_Stat");
    }
  }

/** <em>RawPresorted_Stat$WithEOF</em> ::= <em>RawPresorted_Stat</em> EOF . */
  final public net.sf.crsx.Sink N_RawPresorted_Stat$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_Stat$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawPresorted_Stat(sink, env);
                                                                                                                  token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                             {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_Stat$WithEOF");
    }
  }

/**
 * <em>RawPresorted_Stat</em> ::=  <font color="red">{RAW-VariableUseSorted}</font>   (  <font color="red">{Stat}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-MetaApplicationSorted}</font>   (  <font color="red">{Stat}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-ConstructionSorted}</font>   (  <font color="red">{Stat}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_CONSTRUCTOR">RAW_CONSTRUCTOR</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawScopes">&lang;RawScopes&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |   <a href="#T_RAW_LPAREN">RAW_LPAREN</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawPresorted_Stat(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_Stat");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUseSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "Stat", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_META_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplicationSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "Stat", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        default:
          jj_la1[34] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_CONSTRUCTOR:
                sink = sink .start(makeTConstructor(sink, t, "RAW-ConstructionSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "Stat", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_CONSTRUCTOR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawScopes(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        case T_RAW_LPAREN:
          jj_consume_token(T_RAW_LPAREN);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RPAREN);
          break;
        default:
          jj_la1[35] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_Stat");
    }
  }

/* Raw terms of Type production sort. */

/** <em>Raw_Type$WithEOF</em> ::= <em>Raw_Type</em> EOF . */
  final public net.sf.crsx.Sink N_Raw_Type$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_Type$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_Raw_Type(sink, env);
                                                                                                         token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                    {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_Type$WithEOF");
    }
  }

/**
 * <em>Raw_Type</em> ::=  (   <a href="#T_RAW_TOKEN_Type">RAW_TOKEN_Type</a>  )?   <a href="#N_RawPresorted_Type">&lang;RawPresorted_Type&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Raw_Type(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_Type");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_Type:
        jj_consume_token(T_RAW_TOKEN_Type);
        break;
      default:
        jj_la1[37] = jj_gen;
        ;
      }
      sink = N_RawPresorted_Type(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_Type");
    }
  }

/** <em>RawSorted_Type$WithEOF</em> ::= <em>RawSorted_Type</em> EOF . */
  final public net.sf.crsx.Sink N_RawSorted_Type$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_Type$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSorted_Type(sink, env);
                                                                                                               token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                          {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_Type$WithEOF");
    }
  }

/**
 * <em>RawSorted_Type</em> ::=   <a href="#T_RAW_TOKEN_Type">RAW_TOKEN_Type</a>   <a href="#N_RawPresorted_Type">&lang;RawPresorted_Type&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSorted_Type(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_Type");
    try {
        Token t = null;
      jj_consume_token(T_RAW_TOKEN_Type);
      sink = N_RawPresorted_Type(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_Type");
    }
  }

/** <em>RawPresorted_Type$WithEOF</em> ::= <em>RawPresorted_Type</em> EOF . */
  final public net.sf.crsx.Sink N_RawPresorted_Type$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_Type$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawPresorted_Type(sink, env);
                                                                                                                  token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                             {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_Type$WithEOF");
    }
  }

/**
 * <em>RawPresorted_Type</em> ::=  <font color="red">{RAW-VariableUseSorted}</font>   (  <font color="red">{Type}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-MetaApplicationSorted}</font>   (  <font color="red">{Type}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |   <a href="#T_RAW_TOKEN_Int">RAW_TOKEN_Int</a><font color="red">$</font>   (   <a href="#T_RAW_LPAREN">RAW_LPAREN</a>    <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  )?  <br>
 *  |   <a href="#T_RAW_TOKEN_Float">RAW_TOKEN_Float</a><font color="red">$</font>   (   <a href="#T_RAW_LPAREN">RAW_LPAREN</a>    <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  )?  <br>
 *  |   <a href="#T_RAW_TOKEN_Unif">RAW_TOKEN_Unif</a><font color="red">$</font>    <a href="#T_RAW_LPAREN">RAW_LPAREN</a>   <a href="#N_Raw_Type">&lang;Raw_Type&rang;</a>     <a href="#T_RAW_COMMA">RAW_COMMA</a>   <a href="#N_Raw_Type">&lang;Raw_Type&rang;</a>     <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  <br>
 *  |   <a href="#T_RAW_TOKEN_Test">RAW_TOKEN_Test</a><font color="red">$</font>    <a href="#T_RAW_LPAREN">RAW_LPAREN</a>    <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>    <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">^x_72</font>    <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>   <a href="#N_Raw_Type">&lang;Raw_Type&rang;</a> <font color="red">[x_72]</font>    <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  <br>
 *  |  <font color="red">{RAW-ConstructionSorted}</font>   (  <font color="red">{Type}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_CONSTRUCTOR">RAW_CONSTRUCTOR</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawScopes">&lang;RawScopes&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |   <a href="#T_RAW_LPAREN">RAW_LPAREN</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawPresorted_Type(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_Type");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        String s_x_72 = null;
        net.sf.crsx.Variable v_x_72 = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUseSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "Type", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_META_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplicationSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "Type", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        default:
          jj_la1[38] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_TOKEN_Int:
        t = jj_consume_token(T_RAW_TOKEN_Int);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LPAREN:
          jj_consume_token(T_RAW_LPAREN);
          jj_consume_token(T_RAW_RPAREN);
          break;
        default:
          jj_la1[39] = jj_gen;
          ;
        }
                {if (true) return sink .end() ;}
        break;
      case T_RAW_TOKEN_Float:
        t = jj_consume_token(T_RAW_TOKEN_Float);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LPAREN:
          jj_consume_token(T_RAW_LPAREN);
          jj_consume_token(T_RAW_RPAREN);
          break;
        default:
          jj_la1[40] = jj_gen;
          ;
        }
                {if (true) return sink .end() ;}
        break;
      case T_RAW_TOKEN_Unif:
        t = jj_consume_token(T_RAW_TOKEN_Unif);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
        jj_consume_token(T_RAW_LPAREN);
        sink = N_Raw_Type(sink, env);
        jj_consume_token(T_RAW_COMMA);
        sink = N_Raw_Type(sink, env);
        jj_consume_token(T_RAW_RPAREN);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_TOKEN_Test:
        t = jj_consume_token(T_RAW_TOKEN_Test);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
        jj_consume_token(T_RAW_LPAREN);
        jj_consume_token(T_RAW_LBRACKET);
        t = jj_consume_token(T_RAW_VARIABLE);
                s_x_72 = t.toString();
                v_x_72 = sink.makeVariable(s_x_72,true);
        jj_consume_token(T_RAW_RBRACKET);
                {
                        net.sf.crsx.Variable[] bs1 = {v_x_72};
                        sink = sink .binds(bs1) ;
                }
        sink = N_Raw_Type(sink, env.extend(s_x_72, v_x_72));
        jj_consume_token(T_RAW_RPAREN);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_CONSTRUCTOR:
                sink = sink .start(makeTConstructor(sink, t, "RAW-ConstructionSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "Type", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_CONSTRUCTOR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawScopes(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        case T_RAW_LPAREN:
          jj_consume_token(T_RAW_LPAREN);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RPAREN);
          break;
        default:
          jj_la1[41] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_Type");
    }
  }

/**
 * <em>RawAttributeSynthesized_t</em> ::=  <font color="red">{RAW-Attribute}</font>   (  <font color="red">{RAW-AttributeKindUp}</font>  )   (   <a href="#T_RAW_TOKEN_t">RAW_TOKEN_t</a><font color="red">$</font>  )    <a href="#T_RAW_LPAREN">RAW_LPAREN</a>   <font color="red">{RAW-AttributeValue}</font>   <a href="#N_Raw_Type">&lang;Raw_Type&rang;</a>     <a href="#T_RAW_RPAREN">RAW_RPAREN</a> 
 */
  final public net.sf.crsx.Sink N_RawAttributeSynthesized_t(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawAttributeSynthesized_t");
    try {
        Token t = null;
                sink = sink .start(makeTConstructor(sink, t, "RAW-Attribute", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-AttributeKindUp", null)) ;
                        sink = sink .end() ;
      t = jj_consume_token(T_RAW_TOKEN_t);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
      jj_consume_token(T_RAW_LPAREN);
                sink = sink .start(makeTConstructor(sink, t, "RAW-AttributeValue", null)) ;
      sink = N_Raw_Type(sink, env);
      jj_consume_token(T_RAW_RPAREN);
                {if (true) return sink .end().end() ;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawAttributeSynthesized_t");
    }
  }

/**
 * <em>RawAttributeInherited_e</em> ::=  <font color="red">{RAW-Attribute}</font>   (  <font color="red">{RAW-AttributeKindDown}</font>  )   (   <a href="#T_RAW_TOKEN_e">RAW_TOKEN_e</a><font color="red">$</font>  )    <a href="#T_RAW_LBRACE">RAW_LBRACE</a>   <font color="red">{RAW-AttributeKeyValue}</font>   <a href="#N_Raw_Name">&lang;Raw_Name&rang;</a>     <a href="#T_RAW_COLON">RAW_COLON</a>   <a href="#N_Raw_Type">&lang;Raw_Type&rang;</a>     <a href="#T_RAW_RBRACE">RAW_RBRACE</a> 
 */
  final public net.sf.crsx.Sink N_RawAttributeInherited_e(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawAttributeInherited_e");
    try {
        Token t = null;
                sink = sink .start(makeTConstructor(sink, t, "RAW-Attribute", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-AttributeKindDown", null)) ;
                        sink = sink .end() ;
      t = jj_consume_token(T_RAW_TOKEN_e);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
      jj_consume_token(T_RAW_LBRACE);
                sink = sink .start(makeTConstructor(sink, t, "RAW-AttributeKeyValue", null)) ;
      sink = N_Raw_Name(sink, env);
      jj_consume_token(T_RAW_COLON);
      sink = N_Raw_Type(sink, env);
      jj_consume_token(T_RAW_RBRACE);
                {if (true) return sink .end().end() ;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawAttributeInherited_e");
    }
  }

/* Productions for T token. */

/**
 * <em>T</em> ::=   <a href="#T_meta1_T_M_T">meta1_T_M_T</a><font color="red">:unmeta</font>  <br>
 *  |   <a href="#T_meta2_T_M_T">meta2_T_M_T</a><font color="red">$$:unmeta:{firstRawSorted_T}</font>  <br>
 *  |   <a href="#T_T_M_T">T_M_T</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_T(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_T");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_T:
        t = jj_consume_token(T_meta1_T_M_T);
                sink = sink .start(makeTConstructor(sink, t, unmeta(t.toString()), null)) ;
                {if (true) return sink .end() ;}
        break;
      case T_meta2_T_M_T:
        t = jj_consume_token(T_meta2_T_M_T);
                try {sink = factory.parser(factory).parse(sink, "firstRawSorted_T", new java.io.StringReader(unmeta(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_T_M_T:
        t = jj_consume_token(T_T_M_T);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_T");
    }
  }

/* Raw terms of T token sort. */

/** <em>Raw_T$WithEOF</em> ::= <em>Raw_T</em> EOF . */
  final public net.sf.crsx.Sink N_Raw_T$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_T$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_Raw_T(sink, env);
                                                                                                      token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                 {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_T$WithEOF");
    }
  }

/**
 * <em>Raw_T</em> ::=  (   <a href="#T_RAW_TOKEN_T">RAW_TOKEN_T</a>  )?   <a href="#N_RawPresorted_T">&lang;RawPresorted_T&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Raw_T(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_T");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_T:
        jj_consume_token(T_RAW_TOKEN_T);
        break;
      default:
        jj_la1[44] = jj_gen;
        ;
      }
      sink = N_RawPresorted_T(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_T");
    }
  }

/** <em>RawSorted_T$WithEOF</em> ::= <em>RawSorted_T</em> EOF . */
  final public net.sf.crsx.Sink N_RawSorted_T$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_T$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSorted_T(sink, env);
                                                                                                            token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                       {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_T$WithEOF");
    }
  }

/**
 * <em>RawSorted_T</em> ::=   <a href="#T_RAW_TOKEN_T">RAW_TOKEN_T</a>   <a href="#N_RawPresorted_T">&lang;RawPresorted_T&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSorted_T(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_T");
    try {
        Token t = null;
      jj_consume_token(T_RAW_TOKEN_T);
      sink = N_RawPresorted_T(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_T");
    }
  }

/** <em>RawPresorted_T$WithEOF</em> ::= <em>RawPresorted_T</em> EOF . */
  final public net.sf.crsx.Sink N_RawPresorted_T$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_T$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawPresorted_T(sink, env);
                                                                                                               token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                          {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_T$WithEOF");
    }
  }

/**
 * <em>RawPresorted_T</em> ::=  <font color="red">{RAW-VariableUseSorted}</font>   (  <font color="red">{T}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-MetaApplicationSorted}</font>   (  <font color="red">{T}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawPresorted_T(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_T");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUseSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "T", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_META_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplicationSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "T", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        default:
          jj_la1[45] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[46] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_T");
    }
  }

/* Productions for I_Progr sort with (highest) precedence 0. */

/** <em>I_Progr$WithEOF</em> ::= <em>I_Progr</em> EOF . */
  final public net.sf.crsx.Sink N_I_Progr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_I_Progr$WithEOF");
    try {
  int savedState = token_source.curLexState;
      sink = N_I_Progr(sink, env);
                                                                          token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_I_Progr$WithEOF");
    }
  }

/**
 * <em>I_Progr</em> ::=   <a href="#T_meta1_T_M_I_xProgr">meta1_T_M_I_xProgr</a><font color="red">:unmeta</font>  <br>
 *  |   <a href="#T_meta2_T_M_I_xProgr">meta2_T_M_I_xProgr</a><font color="red">$$:unmeta:{firstRawSorted_I_Progr}</font>  <br>
 *  |  (   "<code>ICG</code>"    "<code>{</code>"   <a href="#N_Stat">&lang;Stat&rang;</a> <font color="red">:#_Stat_1</font>    "<code>}</code>"   <font color="red">{{ I_Progr__M_ICG__M__7b_Stat__M__7d[#_Stat_1]}}</font>  |  (   "<code>ICGExp</code>"   <a href="#N_Tmp">&lang;Tmp&rang;</a> <font color="red">:#_Tmp_1</font>   <a href="#N_Exp">&lang;Exp&rang;</a> <font color="red">:#_Exp_2</font>   <font color="red">{{ I_Progr__M_ICGExp_Tmp_Exp[#_Tmp_1, #_Exp_2]}}</font>  |  (   "<code>{</code>"   <a href="#N_I_Progr">&lang;I_Progr&rang;</a> <font color="red">:#_I_Progr_1</font>    "<code>}</code>"   <a href="#N_I_Progr">&lang;I_Progr&rang;</a> <font color="red">:#_I_Progr_2</font>   <font color="red">{{ I_Progr__M__7b_I_Progr__M__7d_I_Progr[#_I_Progr_1, #_I_Progr_2]}}</font>  |  (  <a href="#N_I_Instr">&lang;I_Instr&rang;</a> <font color="red">:#_I_Instr_1</font>   <a href="#N_I_Progr">&lang;I_Progr&rang;</a> <font color="red">:#_I_Progr_2</font>   <font color="red">{{I_Progr_I_Instr_I_Progr[#_I_Instr_1, #_I_Progr_2]}}</font>  |  <font color="red">{{I_ProgrEMPTY}}</font>  )  )  )  ) 
 */
  final public net.sf.crsx.Sink N_I_Progr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_I_Progr");
    try {
        net.sf.crsx.Sink bs___Tmp_1 = null;
        net.sf.crsx.util.Buffer b___I_Instr_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___I_Progr_2 = null;
        net.sf.crsx.Sink bs___I_Progr_1 = null;
        net.sf.crsx.util.Buffer b___Stat_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___Exp_2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___I_Progr_2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Stat_1 = null;
        net.sf.crsx.Sink bs___I_Instr_1 = null;
        Token t = null;
        net.sf.crsx.Sink bs___Exp_2 = null;
        net.sf.crsx.util.Buffer b___Tmp_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___I_Progr_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_I_xProgr:
        t = jj_consume_token(T_meta1_T_M_I_xProgr);
                sink = sink .start(makeTConstructor(sink, t, unmeta(t.toString()), null)) ;
                {if (true) return sink .end() ;}
        break;
      case T_meta2_T_M_I_xProgr:
        t = jj_consume_token(T_meta2_T_M_I_xProgr);
                try {sink = factory.parser(factory).parse(sink, "firstRawSorted_I_Progr", new java.io.StringReader(unmeta(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      default:
        jj_la1[51] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 60:
          jj_consume_token(60);
          jj_consume_token(41);
                        bs___Stat_1 = b___Stat_1.sink();
          N_Stat(bs___Stat_1, env);
          jj_consume_token(42);
                        sink = sink .start(sink.makeConstructor("I_Progr__M_ICG__M__7b_Stat__M__7d")) .copy(b___Stat_1, true) .end() ;
          break;
        default:
          jj_la1[50] = jj_gen;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 61:
            jj_consume_token(61);
                                bs___Tmp_1 = b___Tmp_1.sink();
            N_Tmp(bs___Tmp_1, env);
                                bs___Exp_2 = b___Exp_2.sink();
            N_Exp(bs___Exp_2, env);
                                sink = sink .start(sink.makeConstructor("I_Progr__M_ICGExp_Tmp_Exp")) .copy(b___Tmp_1, true) .copy(b___Exp_2, true) .end() ;
            break;
          default:
            jj_la1[49] = jj_gen;
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 41:
              jj_consume_token(41);
                                        bs___I_Progr_1 = b___I_Progr_1.sink();
              N_I_Progr(bs___I_Progr_1, env);
              jj_consume_token(42);
                                        bs___I_Progr_2 = b___I_Progr_2.sink();
              N_I_Progr(bs___I_Progr_2, env);
                                        sink = sink .start(sink.makeConstructor("I_Progr__M__7b_I_Progr__M__7d_I_Progr")) .copy(b___I_Progr_1, true) .copy(b___I_Progr_2, true) .end() ;
              break;
            default:
              jj_la1[48] = jj_gen;
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case T_meta1_T_M_ID:
              case T_meta2_T_M_ID:
              case T_meta1_T_M_Name:
              case T_meta2_T_M_Name:
              case T_meta1_T_M_T:
              case T_meta2_T_M_T:
              case T_meta1_T_M_I_xInstr:
              case T_meta2_T_M_I_xInstr:
              case T_meta1_T_M_Tmp:
              case T_meta2_T_M_Tmp:
              case T_T_M_ID:
              case T_T_M_T:
                                                bs___I_Instr_1 = b___I_Instr_1.sink();
                N_I_Instr(bs___I_Instr_1, env);
                                                bs___I_Progr_2 = b___I_Progr_2.sink();
                N_I_Progr(bs___I_Progr_2, env);
                                                sink = sink .start(sink.makeConstructor("I_Progr_I_Instr_I_Progr")) .copy(b___I_Instr_1, true) .copy(b___I_Progr_2, true) .end() ;
                break;
              default:
                jj_la1[47] = jj_gen;
                                                sink = sink .start(sink.makeConstructor("I_ProgrEMPTY")) .end() ;
              }
            }
          }
        }
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_I_Progr");
    }
  }

/* Raw terms of I_Progr production sort. */

/** <em>Raw_I_Progr$WithEOF</em> ::= <em>Raw_I_Progr</em> EOF . */
  final public net.sf.crsx.Sink N_Raw_I_Progr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_I_Progr$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_Raw_I_Progr(sink, env);
                                                                                                            token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                       {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_I_Progr$WithEOF");
    }
  }

/**
 * <em>Raw_I_Progr</em> ::=  (   <a href="#T_RAW_TOKEN_I_Progr">RAW_TOKEN_I_Progr</a>  )?   <a href="#N_RawPresorted_I_Progr">&lang;RawPresorted_I_Progr&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Raw_I_Progr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_I_Progr");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_I_Progr:
        jj_consume_token(T_RAW_TOKEN_I_Progr);
        break;
      default:
        jj_la1[52] = jj_gen;
        ;
      }
      sink = N_RawPresorted_I_Progr(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_I_Progr");
    }
  }

/** <em>RawSorted_I_Progr$WithEOF</em> ::= <em>RawSorted_I_Progr</em> EOF . */
  final public net.sf.crsx.Sink N_RawSorted_I_Progr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_I_Progr$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSorted_I_Progr(sink, env);
                                                                                                                  token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                             {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_I_Progr$WithEOF");
    }
  }

/**
 * <em>RawSorted_I_Progr</em> ::=   <a href="#T_RAW_TOKEN_I_Progr">RAW_TOKEN_I_Progr</a>   <a href="#N_RawPresorted_I_Progr">&lang;RawPresorted_I_Progr&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSorted_I_Progr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_I_Progr");
    try {
        Token t = null;
      jj_consume_token(T_RAW_TOKEN_I_Progr);
      sink = N_RawPresorted_I_Progr(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_I_Progr");
    }
  }

/** <em>RawPresorted_I_Progr$WithEOF</em> ::= <em>RawPresorted_I_Progr</em> EOF . */
  final public net.sf.crsx.Sink N_RawPresorted_I_Progr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_I_Progr$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawPresorted_I_Progr(sink, env);
                                                                                                                     token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                                {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_I_Progr$WithEOF");
    }
  }

/**
 * <em>RawPresorted_I_Progr</em> ::=  <font color="red">{RAW-VariableUseSorted}</font>   (  <font color="red">{I_Progr}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-MetaApplicationSorted}</font>   (  <font color="red">{I_Progr}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-ConstructionSorted}</font>   (  <font color="red">{I_Progr}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_CONSTRUCTOR">RAW_CONSTRUCTOR</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawScopes">&lang;RawScopes&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |   <a href="#T_RAW_LPAREN">RAW_LPAREN</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawPresorted_I_Progr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_I_Progr");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUseSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "I_Progr", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_META_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplicationSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "I_Progr", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        default:
          jj_la1[53] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_CONSTRUCTOR:
                sink = sink .start(makeTConstructor(sink, t, "RAW-ConstructionSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "I_Progr", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_CONSTRUCTOR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawScopes(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        case T_RAW_LPAREN:
          jj_consume_token(T_RAW_LPAREN);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RPAREN);
          break;
        default:
          jj_la1[54] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_I_Progr");
    }
  }

/* Productions for I_Instr sort with (highest) precedence 0. */

/** <em>I_Instr$WithEOF</em> ::= <em>I_Instr</em> EOF . */
  final public net.sf.crsx.Sink N_I_Instr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_I_Instr$WithEOF");
    try {
  int savedState = token_source.curLexState;
      sink = N_I_Instr(sink, env);
                                                                          token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_I_Instr$WithEOF");
    }
  }

/**
 * <em>I_Instr</em> ::=   <a href="#T_meta1_T_M_I_xInstr">meta1_T_M_I_xInstr</a><font color="red">:unmeta</font>  <br>
 *  |   <a href="#T_meta2_T_M_I_xInstr">meta2_T_M_I_xInstr</a><font color="red">$$:unmeta:{firstRawSorted_I_Instr}</font>  <br>
 *  |  (  <a href="#N_Tmp">&lang;Tmp&rang;</a> <font color="red">:#_Tmp_1</font>    "<code>=</code>"   <a href="#N_I_Arg">&lang;I_Arg&rang;</a> <font color="red">:#_I_Arg_2</font>   (   "<code>*</code>"   <a href="#N_I_Arg">&lang;I_Arg&rang;</a> <font color="red">:#_I_Arg_3</font>    "<code>;</code>"   <font color="red">{{I_Instr_Tmp__M__3d_I_Arg__M__2a_I_Arg__M__3b[#_Tmp_1, #_I_Arg_2, #_I_Arg_3]}}</font>  |  (   "<code>+</code>"   <a href="#N_I_Arg">&lang;I_Arg&rang;</a> <font color="red">:#_I_Arg_3</font>    "<code>;</code>"   <font color="red">{{I_Instr_Tmp__M__3d_I_Arg__M__2b_I_Arg__M__3b[#_Tmp_1, #_I_Arg_2, #_I_Arg_3]}}</font>  |   "<code>;</code>"   <font color="red">{{I_Instr_Tmp__M__3d_I_Arg__M__3b[#_Tmp_1, #_I_Arg_2]}}</font>  )  )  |  <a href="#N_Name">&lang;Name&rang;</a> <font color="red">:#_Name_1</font>    "<code>=</code>"   <a href="#N_Tmp">&lang;Tmp&rang;</a> <font color="red">:#_Tmp_2</font>    "<code>;</code>"   <font color="red">{{I_Instr_Name__M__3d_Tmp__M__3b[#_Name_1, #_Tmp_2]}}</font>  ) 
 */
  final public net.sf.crsx.Sink N_I_Instr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_I_Instr");
    try {
        net.sf.crsx.Sink bs___Tmp_1 = null;
        net.sf.crsx.Sink bs___Name_1 = null;
        Token t = null;
        net.sf.crsx.util.Buffer b___I_Arg_2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___I_Arg_3 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Tmp_2 = null;
        net.sf.crsx.util.Buffer b___Name_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___I_Arg_3 = null;
        net.sf.crsx.util.Buffer b___Tmp_2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___I_Arg_2 = null;
        net.sf.crsx.util.Buffer b___Tmp_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_I_xInstr:
        t = jj_consume_token(T_meta1_T_M_I_xInstr);
                sink = sink .start(makeTConstructor(sink, t, unmeta(t.toString()), null)) ;
                {if (true) return sink .end() ;}
        break;
      case T_meta2_T_M_I_xInstr:
        t = jj_consume_token(T_meta2_T_M_I_xInstr);
                try {sink = factory.parser(factory).parse(sink, "firstRawSorted_I_Instr", new java.io.StringReader(unmeta(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta1_T_M_ID:
      case T_meta2_T_M_ID:
      case T_meta1_T_M_Name:
      case T_meta2_T_M_Name:
      case T_meta1_T_M_T:
      case T_meta2_T_M_T:
      case T_meta1_T_M_Tmp:
      case T_meta2_T_M_Tmp:
      case T_T_M_ID:
      case T_T_M_T:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_meta1_T_M_T:
        case T_meta2_T_M_T:
        case T_meta1_T_M_Tmp:
        case T_meta2_T_M_Tmp:
        case T_T_M_T:
                        bs___Tmp_1 = b___Tmp_1.sink();
          N_Tmp(bs___Tmp_1, env);
          jj_consume_token(69);
                        bs___I_Arg_2 = b___I_Arg_2.sink();
          N_I_Arg(bs___I_Arg_2, env);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 24:
            jj_consume_token(24);
                                bs___I_Arg_3 = b___I_Arg_3.sink();
            N_I_Arg(bs___I_Arg_3, env);
            jj_consume_token(45);
                                sink = sink .start(sink.makeConstructor("I_Instr_Tmp__M__3d_I_Arg__M__2a_I_Arg__M__3b")) .copy(b___Tmp_1, true) .copy(b___I_Arg_2, true) .copy(b___I_Arg_3, true) .end() ;
            break;
          case 23:
          case 45:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 23:
              jj_consume_token(23);
                                        bs___I_Arg_3 = b___I_Arg_3.sink();
              N_I_Arg(bs___I_Arg_3, env);
              jj_consume_token(45);
                                        sink = sink .start(sink.makeConstructor("I_Instr_Tmp__M__3d_I_Arg__M__2b_I_Arg__M__3b")) .copy(b___Tmp_1, true) .copy(b___I_Arg_2, true) .copy(b___I_Arg_3, true) .end() ;
              break;
            case 45:
              jj_consume_token(45);
                                        sink = sink .start(sink.makeConstructor("I_Instr_Tmp__M__3d_I_Arg__M__3b")) .copy(b___Tmp_1, true) .copy(b___I_Arg_2, true) .end() ;
              break;
            default:
              jj_la1[56] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[57] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        case T_meta1_T_M_ID:
        case T_meta2_T_M_ID:
        case T_meta1_T_M_Name:
        case T_meta2_T_M_Name:
        case T_T_M_ID:
                        bs___Name_1 = b___Name_1.sink();
          N_Name(bs___Name_1, env);
          jj_consume_token(69);
                        bs___Tmp_2 = b___Tmp_2.sink();
          N_Tmp(bs___Tmp_2, env);
          jj_consume_token(45);
                        sink = sink .start(sink.makeConstructor("I_Instr_Name__M__3d_Tmp__M__3b")) .copy(b___Name_1, true) .copy(b___Tmp_2, true) .end() ;
          break;
        default:
          jj_la1[58] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[59] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_I_Instr");
    }
  }

/* Raw terms of I_Instr production sort. */

/** <em>Raw_I_Instr$WithEOF</em> ::= <em>Raw_I_Instr</em> EOF . */
  final public net.sf.crsx.Sink N_Raw_I_Instr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_I_Instr$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_Raw_I_Instr(sink, env);
                                                                                                            token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                       {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_I_Instr$WithEOF");
    }
  }

/**
 * <em>Raw_I_Instr</em> ::=  (   <a href="#T_RAW_TOKEN_I_Instr">RAW_TOKEN_I_Instr</a>  )?   <a href="#N_RawPresorted_I_Instr">&lang;RawPresorted_I_Instr&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Raw_I_Instr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_I_Instr");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_I_Instr:
        jj_consume_token(T_RAW_TOKEN_I_Instr);
        break;
      default:
        jj_la1[60] = jj_gen;
        ;
      }
      sink = N_RawPresorted_I_Instr(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_I_Instr");
    }
  }

/** <em>RawSorted_I_Instr$WithEOF</em> ::= <em>RawSorted_I_Instr</em> EOF . */
  final public net.sf.crsx.Sink N_RawSorted_I_Instr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_I_Instr$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSorted_I_Instr(sink, env);
                                                                                                                  token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                             {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_I_Instr$WithEOF");
    }
  }

/**
 * <em>RawSorted_I_Instr</em> ::=   <a href="#T_RAW_TOKEN_I_Instr">RAW_TOKEN_I_Instr</a>   <a href="#N_RawPresorted_I_Instr">&lang;RawPresorted_I_Instr&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSorted_I_Instr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_I_Instr");
    try {
        Token t = null;
      jj_consume_token(T_RAW_TOKEN_I_Instr);
      sink = N_RawPresorted_I_Instr(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_I_Instr");
    }
  }

/** <em>RawPresorted_I_Instr$WithEOF</em> ::= <em>RawPresorted_I_Instr</em> EOF . */
  final public net.sf.crsx.Sink N_RawPresorted_I_Instr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_I_Instr$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawPresorted_I_Instr(sink, env);
                                                                                                                     token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                                {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_I_Instr$WithEOF");
    }
  }

/**
 * <em>RawPresorted_I_Instr</em> ::=  <font color="red">{RAW-VariableUseSorted}</font>   (  <font color="red">{I_Instr}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-MetaApplicationSorted}</font>   (  <font color="red">{I_Instr}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-ConstructionSorted}</font>   (  <font color="red">{I_Instr}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_CONSTRUCTOR">RAW_CONSTRUCTOR</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawScopes">&lang;RawScopes&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |   <a href="#T_RAW_LPAREN">RAW_LPAREN</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawPresorted_I_Instr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_I_Instr");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUseSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "I_Instr", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_META_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplicationSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "I_Instr", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        default:
          jj_la1[61] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_CONSTRUCTOR:
                sink = sink .start(makeTConstructor(sink, t, "RAW-ConstructionSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "I_Instr", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_CONSTRUCTOR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawScopes(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        case T_RAW_LPAREN:
          jj_consume_token(T_RAW_LPAREN);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RPAREN);
          break;
        default:
          jj_la1[62] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[63] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_I_Instr");
    }
  }

/* Productions for I_Arg sort with (highest) precedence 0. */

/** <em>I_Arg$WithEOF</em> ::= <em>I_Arg</em> EOF . */
  final public net.sf.crsx.Sink N_I_Arg$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_I_Arg$WithEOF");
    try {
  int savedState = token_source.curLexState;
      sink = N_I_Arg(sink, env);
                                                                        token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                   {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_I_Arg$WithEOF");
    }
  }

/**
 * <em>I_Arg</em> ::=   <a href="#T_meta1_T_M_I_xArg">meta1_T_M_I_xArg</a><font color="red">:unmeta</font>  <br>
 *  |   <a href="#T_meta2_T_M_I_xArg">meta2_T_M_I_xArg</a><font color="red">$$:unmeta:{firstRawSorted_I_Arg}</font>  <br>
 *  |  (  <a href="#N_Name">&lang;Name&rang;</a> <font color="red">:#_Name_1</font>   <font color="red">{{I_Arg_Name[#_Name_1]}}</font>  |  (  <a href="#N_FLOAT">&lang;FLOAT&rang;</a> <font color="red">:#_FLOAT_1</font>   <font color="red">{{I_Arg_FLOAT[#_FLOAT_1]}}</font>  |  (  <a href="#N_INT">&lang;INT&rang;</a> <font color="red">:#_INT_1</font>   <font color="red">{{I_Arg_INT[#_INT_1]}}</font>  |  <a href="#N_Tmp">&lang;Tmp&rang;</a> <font color="red">:#_Tmp_1</font>   <font color="red">{{I_Arg_Tmp[#_Tmp_1]}}</font>  )  )  ) 
 */
  final public net.sf.crsx.Sink N_I_Arg(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_I_Arg");
    try {
        net.sf.crsx.Sink bs___Tmp_1 = null;
        net.sf.crsx.Sink bs___Name_1 = null;
        Token t = null;
        net.sf.crsx.util.Buffer b___Name_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___FLOAT_1 = null;
        net.sf.crsx.util.Buffer b___Tmp_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___INT_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___INT_1 = null;
        net.sf.crsx.util.Buffer b___FLOAT_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_I_xArg:
        t = jj_consume_token(T_meta1_T_M_I_xArg);
                sink = sink .start(makeTConstructor(sink, t, unmeta(t.toString()), null)) ;
                {if (true) return sink .end() ;}
        break;
      case T_meta2_T_M_I_xArg:
        t = jj_consume_token(T_meta2_T_M_I_xArg);
                try {sink = factory.parser(factory).parse(sink, "firstRawSorted_I_Arg", new java.io.StringReader(unmeta(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta1_T_M_INT:
      case T_meta2_T_M_INT:
      case T_meta1_T_M_FLOAT:
      case T_meta2_T_M_FLOAT:
      case T_meta1_T_M_ID:
      case T_meta2_T_M_ID:
      case T_meta1_T_M_Name:
      case T_meta2_T_M_Name:
      case T_meta1_T_M_T:
      case T_meta2_T_M_T:
      case T_meta1_T_M_Tmp:
      case T_meta2_T_M_Tmp:
      case T_T_M_INT:
      case T_T_M_FLOAT:
      case T_T_M_ID:
      case T_T_M_T:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_meta1_T_M_ID:
        case T_meta2_T_M_ID:
        case T_meta1_T_M_Name:
        case T_meta2_T_M_Name:
        case T_T_M_ID:
                        bs___Name_1 = b___Name_1.sink();
          N_Name(bs___Name_1, env);
                        sink = sink .start(sink.makeConstructor("I_Arg_Name")) .copy(b___Name_1, true) .end() ;
          break;
        case T_meta1_T_M_INT:
        case T_meta2_T_M_INT:
        case T_meta1_T_M_FLOAT:
        case T_meta2_T_M_FLOAT:
        case T_meta1_T_M_T:
        case T_meta2_T_M_T:
        case T_meta1_T_M_Tmp:
        case T_meta2_T_M_Tmp:
        case T_T_M_INT:
        case T_T_M_FLOAT:
        case T_T_M_T:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case T_meta1_T_M_FLOAT:
          case T_meta2_T_M_FLOAT:
          case T_T_M_FLOAT:
                                bs___FLOAT_1 = b___FLOAT_1.sink();
            N_FLOAT(bs___FLOAT_1, env);
                                sink = sink .start(sink.makeConstructor("I_Arg_FLOAT")) .copy(b___FLOAT_1, true) .end() ;
            break;
          case T_meta1_T_M_INT:
          case T_meta2_T_M_INT:
          case T_meta1_T_M_T:
          case T_meta2_T_M_T:
          case T_meta1_T_M_Tmp:
          case T_meta2_T_M_Tmp:
          case T_T_M_INT:
          case T_T_M_T:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case T_meta1_T_M_INT:
            case T_meta2_T_M_INT:
            case T_T_M_INT:
                                        bs___INT_1 = b___INT_1.sink();
              N_INT(bs___INT_1, env);
                                        sink = sink .start(sink.makeConstructor("I_Arg_INT")) .copy(b___INT_1, true) .end() ;
              break;
            case T_meta1_T_M_T:
            case T_meta2_T_M_T:
            case T_meta1_T_M_Tmp:
            case T_meta2_T_M_Tmp:
            case T_T_M_T:
                                        bs___Tmp_1 = b___Tmp_1.sink();
              N_Tmp(bs___Tmp_1, env);
                                        sink = sink .start(sink.makeConstructor("I_Arg_Tmp")) .copy(b___Tmp_1, true) .end() ;
              break;
            default:
              jj_la1[64] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[65] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[66] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[67] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_I_Arg");
    }
  }

/* Raw terms of I_Arg production sort. */

/** <em>Raw_I_Arg$WithEOF</em> ::= <em>Raw_I_Arg</em> EOF . */
  final public net.sf.crsx.Sink N_Raw_I_Arg$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_I_Arg$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_Raw_I_Arg(sink, env);
                                                                                                          token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_I_Arg$WithEOF");
    }
  }

/**
 * <em>Raw_I_Arg</em> ::=  (   <a href="#T_RAW_TOKEN_I_Arg">RAW_TOKEN_I_Arg</a>  )?   <a href="#N_RawPresorted_I_Arg">&lang;RawPresorted_I_Arg&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Raw_I_Arg(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_I_Arg");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_I_Arg:
        jj_consume_token(T_RAW_TOKEN_I_Arg);
        break;
      default:
        jj_la1[68] = jj_gen;
        ;
      }
      sink = N_RawPresorted_I_Arg(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_I_Arg");
    }
  }

/** <em>RawSorted_I_Arg$WithEOF</em> ::= <em>RawSorted_I_Arg</em> EOF . */
  final public net.sf.crsx.Sink N_RawSorted_I_Arg$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_I_Arg$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSorted_I_Arg(sink, env);
                                                                                                                token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                           {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_I_Arg$WithEOF");
    }
  }

/**
 * <em>RawSorted_I_Arg</em> ::=   <a href="#T_RAW_TOKEN_I_Arg">RAW_TOKEN_I_Arg</a>   <a href="#N_RawPresorted_I_Arg">&lang;RawPresorted_I_Arg&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSorted_I_Arg(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_I_Arg");
    try {
        Token t = null;
      jj_consume_token(T_RAW_TOKEN_I_Arg);
      sink = N_RawPresorted_I_Arg(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_I_Arg");
    }
  }

/** <em>RawPresorted_I_Arg$WithEOF</em> ::= <em>RawPresorted_I_Arg</em> EOF . */
  final public net.sf.crsx.Sink N_RawPresorted_I_Arg$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_I_Arg$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawPresorted_I_Arg(sink, env);
                                                                                                                   token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                              {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_I_Arg$WithEOF");
    }
  }

/**
 * <em>RawPresorted_I_Arg</em> ::=  <font color="red">{RAW-VariableUseSorted}</font>   (  <font color="red">{I_Arg}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-MetaApplicationSorted}</font>   (  <font color="red">{I_Arg}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-ConstructionSorted}</font>   (  <font color="red">{I_Arg}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_CONSTRUCTOR">RAW_CONSTRUCTOR</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawScopes">&lang;RawScopes&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |   <a href="#T_RAW_LPAREN">RAW_LPAREN</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawPresorted_I_Arg(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_I_Arg");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUseSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "I_Arg", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_META_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplicationSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "I_Arg", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        default:
          jj_la1[69] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_CONSTRUCTOR:
                sink = sink .start(makeTConstructor(sink, t, "RAW-ConstructionSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "I_Arg", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_CONSTRUCTOR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawScopes(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        case T_RAW_LPAREN:
          jj_consume_token(T_RAW_LPAREN);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RPAREN);
          break;
        default:
          jj_la1[70] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[71] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_I_Arg");
    }
  }

/* Productions for Tmp sort with (highest) precedence 0. */

/** <em>Tmp$WithEOF</em> ::= <em>Tmp</em> EOF . */
  final public net.sf.crsx.Sink N_Tmp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Tmp$WithEOF");
    try {
  int savedState = token_source.curLexState;
      sink = N_Tmp(sink, env);
                                                                      token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                 {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Tmp$WithEOF");
    }
  }

/**
 * <em>Tmp</em> ::=   <a href="#T_meta1_T_M_Tmp">meta1_T_M_Tmp</a><font color="red">:unmeta</font>  <br>
 *  |   <a href="#T_meta2_T_M_Tmp">meta2_T_M_Tmp</a><font color="red">$$:unmeta:{firstRawSorted_Tmp}</font>  <br>
 *  |  <a href="#N_T">&lang;T&rang;</a> <font color="red">!!!:#_T_1</font>   <font color="red">{{#_T_1}}</font> 
 */
  final public net.sf.crsx.Sink N_Tmp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Tmp");
    try {
        net.sf.crsx.Variable v___T_1 = null;
        net.sf.crsx.Sink bs___T_1 = null;
        Token t = null;
        String c1 = null;
        String s___T_1 = null;
        net.sf.crsx.util.Buffer b___T_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_Tmp:
        t = jj_consume_token(T_meta1_T_M_Tmp);
                sink = sink .start(makeTConstructor(sink, t, unmeta(t.toString()), null)) ;
                {if (true) return sink .end() ;}
        break;
      case T_meta2_T_M_Tmp:
        t = jj_consume_token(T_meta2_T_M_Tmp);
                try {sink = factory.parser(factory).parse(sink, "firstRawSorted_Tmp", new java.io.StringReader(unmeta(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta1_T_M_T:
      case T_meta2_T_M_T:
      case T_T_M_T:
                bs___T_1 = b___T_1.sink();
        N_T(bs___T_1, env);
                c1 = net.sf.crsx.util.Util.symbol(b___T_1.term(true));
                s___T_1 = c1;
                v___T_1 = (env.containsKey(s___T_1) ? env.get(s___T_1) : factory.freeVariable(s___T_1, true, true));
                if (v___T_1 == null) {if (true) throw new ParseException("Variable "+s___T_1+" cannot be resolved?");}
                sink = sink .use(v___T_1) ;
         {if (true) return sink;}
        break;
      default:
        jj_la1[72] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Tmp");
    }
  }

/* Raw terms of Tmp production sort. */

/** <em>Raw_Tmp$WithEOF</em> ::= <em>Raw_Tmp</em> EOF . */
  final public net.sf.crsx.Sink N_Raw_Tmp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_Tmp$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_Raw_Tmp(sink, env);
                                                                                                        token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                   {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_Tmp$WithEOF");
    }
  }

/**
 * <em>Raw_Tmp</em> ::=  (   <a href="#T_RAW_TOKEN_Tmp">RAW_TOKEN_Tmp</a>  )?   <a href="#N_RawPresorted_Tmp">&lang;RawPresorted_Tmp&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Raw_Tmp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_Tmp");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_Tmp:
        jj_consume_token(T_RAW_TOKEN_Tmp);
        break;
      default:
        jj_la1[73] = jj_gen;
        ;
      }
      sink = N_RawPresorted_Tmp(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_Tmp");
    }
  }

/** <em>RawSorted_Tmp$WithEOF</em> ::= <em>RawSorted_Tmp</em> EOF . */
  final public net.sf.crsx.Sink N_RawSorted_Tmp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_Tmp$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSorted_Tmp(sink, env);
                                                                                                              token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_Tmp$WithEOF");
    }
  }

/**
 * <em>RawSorted_Tmp</em> ::=   <a href="#T_RAW_TOKEN_Tmp">RAW_TOKEN_Tmp</a>   <a href="#N_RawPresorted_Tmp">&lang;RawPresorted_Tmp&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSorted_Tmp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_Tmp");
    try {
        Token t = null;
      jj_consume_token(T_RAW_TOKEN_Tmp);
      sink = N_RawPresorted_Tmp(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_Tmp");
    }
  }

/** <em>RawPresorted_Tmp$WithEOF</em> ::= <em>RawPresorted_Tmp</em> EOF . */
  final public net.sf.crsx.Sink N_RawPresorted_Tmp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_Tmp$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawPresorted_Tmp(sink, env);
                                                                                                                 token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                            {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_Tmp$WithEOF");
    }
  }

/**
 * <em>RawPresorted_Tmp</em> ::=  <font color="red">{RAW-VariableUseSorted}</font>   (  <font color="red">{Tmp}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-MetaApplicationSorted}</font>   (  <font color="red">{Tmp}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-ConstructionSorted}</font>   (  <font color="red">{Tmp}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_CONSTRUCTOR">RAW_CONSTRUCTOR</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawScopes">&lang;RawScopes&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |   <a href="#T_RAW_LPAREN">RAW_LPAREN</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawPresorted_Tmp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_Tmp");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUseSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "Tmp", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_META_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplicationSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "Tmp", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        default:
          jj_la1[74] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_CONSTRUCTOR:
                sink = sink .start(makeTConstructor(sink, t, "RAW-ConstructionSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "Tmp", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_CONSTRUCTOR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawScopes(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        case T_RAW_LPAREN:
          jj_consume_token(T_RAW_LPAREN);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RPAREN);
          break;
        default:
          jj_la1[75] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[76] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_Tmp");
    }
  }

/**
 * <em>RawAttributeInherited_TmpType</em> ::=  <font color="red">{RAW-Attribute}</font>   (  <font color="red">{RAW-AttributeKindDown}</font>  )   (   <a href="#T_RAW_TOKEN_TmpType">RAW_TOKEN_TmpType</a><font color="red">$</font>  )    <a href="#T_RAW_LBRACE">RAW_LBRACE</a>   <font color="red">{RAW-AttributeKeyValue}</font>   <a href="#N_Raw_Tmp">&lang;Raw_Tmp&rang;</a>     <a href="#T_RAW_COLON">RAW_COLON</a>   <a href="#N_Raw_Type">&lang;Raw_Type&rang;</a>     <a href="#T_RAW_RBRACE">RAW_RBRACE</a> 
 */
  final public net.sf.crsx.Sink N_RawAttributeInherited_TmpType(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawAttributeInherited_TmpType");
    try {
        Token t = null;
                sink = sink .start(makeTConstructor(sink, t, "RAW-Attribute", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-AttributeKindDown", null)) ;
                        sink = sink .end() ;
      t = jj_consume_token(T_RAW_TOKEN_TmpType);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
      jj_consume_token(T_RAW_LBRACE);
                sink = sink .start(makeTConstructor(sink, t, "RAW-AttributeKeyValue", null)) ;
      sink = N_Raw_Tmp(sink, env);
      jj_consume_token(T_RAW_COLON);
      sink = N_Raw_Type(sink, env);
      jj_consume_token(T_RAW_RBRACE);
                {if (true) return sink .end().end() ;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawAttributeInherited_TmpType");
    }
  }

/* Productions for A_Progr sort with (highest) precedence 0. */

/** <em>A_Progr$WithEOF</em> ::= <em>A_Progr</em> EOF . */
  final public net.sf.crsx.Sink N_A_Progr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_A_Progr$WithEOF");
    try {
  int savedState = token_source.curLexState;
      sink = N_A_Progr(sink, env);
                                                                          token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_A_Progr$WithEOF");
    }
  }

/**
 * <em>A_Progr</em> ::=   <a href="#T_meta1_T_M_A_xProgr">meta1_T_M_A_xProgr</a><font color="red">:unmeta</font>  <br>
 *  |   <a href="#T_meta2_T_M_A_xProgr">meta2_T_M_A_xProgr</a><font color="red">$$:unmeta:{firstRawSorted_A_Progr}</font>  <br>
 *  |  (   "<code>CG</code>"   <a href="#N_I_Progr">&lang;I_Progr&rang;</a> <font color="red">:#_I_Progr_1</font>   <font color="red">{{ A_Progr__M_CG_I_Progr[#_I_Progr_1]}}</font>  |  (   "<code>Compile</code>"   <a href="#N_Stat">&lang;Stat&rang;</a> <font color="red">:#_Stat_1</font>   <font color="red">{{ A_Progr__M_Compile_Stat[#_Stat_1]}}</font>  |  (  <a href="#N_A_Instr">&lang;A_Instr&rang;</a> <font color="red">:#_A_Instr_1</font>   <a href="#N_A_Progr">&lang;A_Progr&rang;</a> <font color="red">:#_A_Progr_2</font>   <font color="red">{{A_Progr_A_Instr_A_Progr[#_A_Instr_1, #_A_Progr_2]}}</font>  |  <font color="red">{{A_ProgrEMPTY}}</font>  )  )  ) 
 */
  final public net.sf.crsx.Sink N_A_Progr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_A_Progr");
    try {
        net.sf.crsx.util.Buffer b___A_Instr_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___A_Progr_2 = null;
        net.sf.crsx.Sink bs___Stat_1 = null;
        Token t = null;
        net.sf.crsx.util.Buffer b___A_Progr_2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___I_Progr_1 = null;
        net.sf.crsx.util.Buffer b___Stat_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___A_Instr_1 = null;
        net.sf.crsx.util.Buffer b___I_Progr_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_A_xProgr:
        t = jj_consume_token(T_meta1_T_M_A_xProgr);
                sink = sink .start(makeTConstructor(sink, t, unmeta(t.toString()), null)) ;
                {if (true) return sink .end() ;}
        break;
      case T_meta2_T_M_A_xProgr:
        t = jj_consume_token(T_meta2_T_M_A_xProgr);
                try {sink = factory.parser(factory).parse(sink, "firstRawSorted_A_Progr", new java.io.StringReader(unmeta(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      default:
        jj_la1[80] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 91:
          jj_consume_token(91);
                        bs___I_Progr_1 = b___I_Progr_1.sink();
          N_I_Progr(bs___I_Progr_1, env);
                        sink = sink .start(sink.makeConstructor("A_Progr__M_CG_I_Progr")) .copy(b___I_Progr_1, true) .end() ;
          break;
        default:
          jj_la1[79] = jj_gen;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 92:
            jj_consume_token(92);
                                bs___Stat_1 = b___Stat_1.sink();
            N_Stat(bs___Stat_1, env);
                                sink = sink .start(sink.makeConstructor("A_Progr__M_Compile_Stat")) .copy(b___Stat_1, true) .end() ;
            break;
          default:
            jj_la1[78] = jj_gen;
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 100:
            case 102:
            case 103:
            case 104:
            case T_meta1_T_M_A_xInstr:
            case T_meta2_T_M_A_xInstr:
                                        bs___A_Instr_1 = b___A_Instr_1.sink();
              N_A_Instr(bs___A_Instr_1, env);
                                        bs___A_Progr_2 = b___A_Progr_2.sink();
              N_A_Progr(bs___A_Progr_2, env);
                                        sink = sink .start(sink.makeConstructor("A_Progr_A_Instr_A_Progr")) .copy(b___A_Instr_1, true) .copy(b___A_Progr_2, true) .end() ;
              break;
            default:
              jj_la1[77] = jj_gen;
                                        sink = sink .start(sink.makeConstructor("A_ProgrEMPTY")) .end() ;
            }
          }
        }
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_A_Progr");
    }
  }

/* Raw terms of A_Progr production sort. */

/** <em>Raw_A_Progr$WithEOF</em> ::= <em>Raw_A_Progr</em> EOF . */
  final public net.sf.crsx.Sink N_Raw_A_Progr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_A_Progr$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_Raw_A_Progr(sink, env);
                                                                                                            token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                       {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_A_Progr$WithEOF");
    }
  }

/**
 * <em>Raw_A_Progr</em> ::=  (   <a href="#T_RAW_TOKEN_A_Progr">RAW_TOKEN_A_Progr</a>  )?   <a href="#N_RawPresorted_A_Progr">&lang;RawPresorted_A_Progr&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Raw_A_Progr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_A_Progr");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_A_Progr:
        jj_consume_token(T_RAW_TOKEN_A_Progr);
        break;
      default:
        jj_la1[81] = jj_gen;
        ;
      }
      sink = N_RawPresorted_A_Progr(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_A_Progr");
    }
  }

/** <em>RawSorted_A_Progr$WithEOF</em> ::= <em>RawSorted_A_Progr</em> EOF . */
  final public net.sf.crsx.Sink N_RawSorted_A_Progr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_A_Progr$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSorted_A_Progr(sink, env);
                                                                                                                  token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                             {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_A_Progr$WithEOF");
    }
  }

/**
 * <em>RawSorted_A_Progr</em> ::=   <a href="#T_RAW_TOKEN_A_Progr">RAW_TOKEN_A_Progr</a>   <a href="#N_RawPresorted_A_Progr">&lang;RawPresorted_A_Progr&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSorted_A_Progr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_A_Progr");
    try {
        Token t = null;
      jj_consume_token(T_RAW_TOKEN_A_Progr);
      sink = N_RawPresorted_A_Progr(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_A_Progr");
    }
  }

/** <em>RawPresorted_A_Progr$WithEOF</em> ::= <em>RawPresorted_A_Progr</em> EOF . */
  final public net.sf.crsx.Sink N_RawPresorted_A_Progr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_A_Progr$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawPresorted_A_Progr(sink, env);
                                                                                                                     token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                                {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_A_Progr$WithEOF");
    }
  }

/**
 * <em>RawPresorted_A_Progr</em> ::=  <font color="red">{RAW-VariableUseSorted}</font>   (  <font color="red">{A_Progr}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-MetaApplicationSorted}</font>   (  <font color="red">{A_Progr}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |   <a href="#T_RAW_TOKEN_Compile">RAW_TOKEN_Compile</a><font color="red">$</font>    <a href="#T_RAW_LPAREN">RAW_LPAREN</a>   <a href="#N_Raw_Stat">&lang;Raw_Stat&rang;</a>     <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  <br>
 *  |  <font color="red">{RAW-ConstructionSorted}</font>   (  <font color="red">{A_Progr}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_CONSTRUCTOR">RAW_CONSTRUCTOR</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawScopes">&lang;RawScopes&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |   <a href="#T_RAW_LPAREN">RAW_LPAREN</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawPresorted_A_Progr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_A_Progr");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUseSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "A_Progr", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_META_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplicationSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "A_Progr", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        default:
          jj_la1[82] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_TOKEN_Compile:
        t = jj_consume_token(T_RAW_TOKEN_Compile);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
        jj_consume_token(T_RAW_LPAREN);
        sink = N_Raw_Stat(sink, env);
        jj_consume_token(T_RAW_RPAREN);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_CONSTRUCTOR:
                sink = sink .start(makeTConstructor(sink, t, "RAW-ConstructionSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "A_Progr", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_CONSTRUCTOR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawScopes(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        case T_RAW_LPAREN:
          jj_consume_token(T_RAW_LPAREN);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RPAREN);
          break;
        default:
          jj_la1[83] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[84] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_A_Progr");
    }
  }

/* Productions for A_Instr sort with (highest) precedence 0. */

/** <em>A_Instr$WithEOF</em> ::= <em>A_Instr</em> EOF . */
  final public net.sf.crsx.Sink N_A_Instr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_A_Instr$WithEOF");
    try {
  int savedState = token_source.curLexState;
      sink = N_A_Instr(sink, env);
                                                                          token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_A_Instr$WithEOF");
    }
  }

/**
 * <em>A_Instr</em> ::=   <a href="#T_meta1_T_M_A_xInstr">meta1_T_M_A_xInstr</a><font color="red">:unmeta</font>  <br>
 *  |   <a href="#T_meta2_T_M_A_xInstr">meta2_T_M_A_xInstr</a><font color="red">$$:unmeta:{firstRawSorted_A_Instr}</font>  <br>
 *  |  (   "<code>ADDF</code>"   <a href="#N_A_Arg">&lang;A_Arg&rang;</a> <font color="red">:#_A_Arg_1</font>    "<code>,</code>"   <a href="#N_A_Arg">&lang;A_Arg&rang;</a> <font color="red">:#_A_Arg_2</font>    "<code>,</code>"   <a href="#N_A_Arg">&lang;A_Arg&rang;</a> <font color="red">:#_A_Arg_3</font>   <font color="red">{{A_Instr__M_ADDF_A_Arg__M__2c_A_Arg__M__2c_A_Arg[#_A_Arg_1, #_A_Arg_2, #_A_Arg_3]}}</font>  |  (   "<code>LDF</code>"   <a href="#N_Tmp">&lang;Tmp&rang;</a> <font color="red">:#_Tmp_1</font>    "<code>,</code>"   <a href="#N_A_Arg">&lang;A_Arg&rang;</a> <font color="red">:#_A_Arg_2</font>   <font color="red">{{A_Instr__M_LDF_Tmp__M__2c_A_Arg[#_Tmp_1, #_A_Arg_2]}}</font>  |  (   "<code>MULF</code>"   <a href="#N_A_Arg">&lang;A_Arg&rang;</a> <font color="red">:#_A_Arg_1</font>    "<code>,</code>"   <a href="#N_A_Arg">&lang;A_Arg&rang;</a> <font color="red">:#_A_Arg_2</font>    "<code>,</code>"   <a href="#N_A_Arg">&lang;A_Arg&rang;</a> <font color="red">:#_A_Arg_3</font>   <font color="red">{{A_Instr__M_MULF_A_Arg__M__2c_A_Arg__M__2c_A_Arg[#_A_Arg_1, #_A_Arg_2, #_A_Arg_3]}}</font>  |   "<code>STF</code>"   <a href="#N_Name">&lang;Name&rang;</a> <font color="red">:#_Name_1</font>    "<code>,</code>"   <a href="#N_Tmp">&lang;Tmp&rang;</a> <font color="red">:#_Tmp_2</font>   <font color="red">{{A_Instr__M_STF_Name__M__2c_Tmp[#_Name_1, #_Tmp_2]}}</font>  )  )  ) 
 */
  final public net.sf.crsx.Sink N_A_Instr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_A_Instr");
    try {
        net.sf.crsx.Sink bs___Tmp_1 = null;
        net.sf.crsx.Sink bs___Name_1 = null;
        net.sf.crsx.util.Buffer b___Name_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Tmp_2 = null;
        net.sf.crsx.util.Buffer b___A_Arg_3 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___A_Arg_2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___A_Arg_1 = new net.sf.crsx.util.Buffer(sink);
        Token t = null;
        net.sf.crsx.Sink bs___A_Arg_3 = null;
        net.sf.crsx.Sink bs___A_Arg_1 = null;
        net.sf.crsx.util.Buffer b___Tmp_2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___A_Arg_2 = null;
        net.sf.crsx.util.Buffer b___Tmp_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_A_xInstr:
        t = jj_consume_token(T_meta1_T_M_A_xInstr);
                sink = sink .start(makeTConstructor(sink, t, unmeta(t.toString()), null)) ;
                {if (true) return sink .end() ;}
        break;
      case T_meta2_T_M_A_xInstr:
        t = jj_consume_token(T_meta2_T_M_A_xInstr);
                try {sink = factory.parser(factory).parse(sink, "firstRawSorted_A_Instr", new java.io.StringReader(unmeta(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case 100:
      case 102:
      case 103:
      case 104:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 100:
          jj_consume_token(100);
                        bs___A_Arg_1 = b___A_Arg_1.sink();
          N_A_Arg(bs___A_Arg_1, env);
          jj_consume_token(101);
                        bs___A_Arg_2 = b___A_Arg_2.sink();
          N_A_Arg(bs___A_Arg_2, env);
          jj_consume_token(101);
                        bs___A_Arg_3 = b___A_Arg_3.sink();
          N_A_Arg(bs___A_Arg_3, env);
                        sink = sink .start(sink.makeConstructor("A_Instr__M_ADDF_A_Arg__M__2c_A_Arg__M__2c_A_Arg")) .copy(b___A_Arg_1, true) .copy(b___A_Arg_2, true) .copy(b___A_Arg_3, true) .end() ;
          break;
        case 102:
        case 103:
        case 104:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 102:
            jj_consume_token(102);
                                bs___Tmp_1 = b___Tmp_1.sink();
            N_Tmp(bs___Tmp_1, env);
            jj_consume_token(101);
                                bs___A_Arg_2 = b___A_Arg_2.sink();
            N_A_Arg(bs___A_Arg_2, env);
                                sink = sink .start(sink.makeConstructor("A_Instr__M_LDF_Tmp__M__2c_A_Arg")) .copy(b___Tmp_1, true) .copy(b___A_Arg_2, true) .end() ;
            break;
          case 103:
          case 104:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 103:
              jj_consume_token(103);
                                        bs___A_Arg_1 = b___A_Arg_1.sink();
              N_A_Arg(bs___A_Arg_1, env);
              jj_consume_token(101);
                                        bs___A_Arg_2 = b___A_Arg_2.sink();
              N_A_Arg(bs___A_Arg_2, env);
              jj_consume_token(101);
                                        bs___A_Arg_3 = b___A_Arg_3.sink();
              N_A_Arg(bs___A_Arg_3, env);
                                        sink = sink .start(sink.makeConstructor("A_Instr__M_MULF_A_Arg__M__2c_A_Arg__M__2c_A_Arg")) .copy(b___A_Arg_1, true) .copy(b___A_Arg_2, true) .copy(b___A_Arg_3, true) .end() ;
              break;
            case 104:
              jj_consume_token(104);
                                        bs___Name_1 = b___Name_1.sink();
              N_Name(bs___Name_1, env);
              jj_consume_token(101);
                                        bs___Tmp_2 = b___Tmp_2.sink();
              N_Tmp(bs___Tmp_2, env);
                                        sink = sink .start(sink.makeConstructor("A_Instr__M_STF_Name__M__2c_Tmp")) .copy(b___Name_1, true) .copy(b___Tmp_2, true) .end() ;
              break;
            default:
              jj_la1[85] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[86] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[87] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[88] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_A_Instr");
    }
  }

/* Raw terms of A_Instr production sort. */

/** <em>Raw_A_Instr$WithEOF</em> ::= <em>Raw_A_Instr</em> EOF . */
  final public net.sf.crsx.Sink N_Raw_A_Instr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_A_Instr$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_Raw_A_Instr(sink, env);
                                                                                                            token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                       {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_A_Instr$WithEOF");
    }
  }

/**
 * <em>Raw_A_Instr</em> ::=  (   <a href="#T_RAW_TOKEN_A_Instr">RAW_TOKEN_A_Instr</a>  )?   <a href="#N_RawPresorted_A_Instr">&lang;RawPresorted_A_Instr&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Raw_A_Instr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_A_Instr");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_A_Instr:
        jj_consume_token(T_RAW_TOKEN_A_Instr);
        break;
      default:
        jj_la1[89] = jj_gen;
        ;
      }
      sink = N_RawPresorted_A_Instr(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_A_Instr");
    }
  }

/** <em>RawSorted_A_Instr$WithEOF</em> ::= <em>RawSorted_A_Instr</em> EOF . */
  final public net.sf.crsx.Sink N_RawSorted_A_Instr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_A_Instr$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSorted_A_Instr(sink, env);
                                                                                                                  token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                             {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_A_Instr$WithEOF");
    }
  }

/**
 * <em>RawSorted_A_Instr</em> ::=   <a href="#T_RAW_TOKEN_A_Instr">RAW_TOKEN_A_Instr</a>   <a href="#N_RawPresorted_A_Instr">&lang;RawPresorted_A_Instr&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSorted_A_Instr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_A_Instr");
    try {
        Token t = null;
      jj_consume_token(T_RAW_TOKEN_A_Instr);
      sink = N_RawPresorted_A_Instr(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_A_Instr");
    }
  }

/** <em>RawPresorted_A_Instr$WithEOF</em> ::= <em>RawPresorted_A_Instr</em> EOF . */
  final public net.sf.crsx.Sink N_RawPresorted_A_Instr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_A_Instr$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawPresorted_A_Instr(sink, env);
                                                                                                                     token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                                {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_A_Instr$WithEOF");
    }
  }

/**
 * <em>RawPresorted_A_Instr</em> ::=  <font color="red">{RAW-VariableUseSorted}</font>   (  <font color="red">{A_Instr}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-MetaApplicationSorted}</font>   (  <font color="red">{A_Instr}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-ConstructionSorted}</font>   (  <font color="red">{A_Instr}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_CONSTRUCTOR">RAW_CONSTRUCTOR</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawScopes">&lang;RawScopes&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |   <a href="#T_RAW_LPAREN">RAW_LPAREN</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawPresorted_A_Instr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_A_Instr");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUseSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "A_Instr", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_META_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplicationSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "A_Instr", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        default:
          jj_la1[90] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_CONSTRUCTOR:
                sink = sink .start(makeTConstructor(sink, t, "RAW-ConstructionSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "A_Instr", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_CONSTRUCTOR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawScopes(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        case T_RAW_LPAREN:
          jj_consume_token(T_RAW_LPAREN);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RPAREN);
          break;
        default:
          jj_la1[91] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[92] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_A_Instr");
    }
  }

/* Productions for A_Arg sort with (highest) precedence 0. */

/** <em>A_Arg$WithEOF</em> ::= <em>A_Arg</em> EOF . */
  final public net.sf.crsx.Sink N_A_Arg$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_A_Arg$WithEOF");
    try {
  int savedState = token_source.curLexState;
      sink = N_A_Arg(sink, env);
                                                                        token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                   {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_A_Arg$WithEOF");
    }
  }

/**
 * <em>A_Arg</em> ::=   <a href="#T_meta1_T_M_A_xArg">meta1_T_M_A_xArg</a><font color="red">:unmeta</font>  <br>
 *  |   <a href="#T_meta2_T_M_A_xArg">meta2_T_M_A_xArg</a><font color="red">$$:unmeta:{firstRawSorted_A_Arg}</font>  <br>
 *  |  (   "<code>#</code>"   (  <a href="#N_FLOAT">&lang;FLOAT&rang;</a> <font color="red">:#_FLOAT_1</font>   <font color="red">{{A_Arg__M__h_FLOAT[#_FLOAT_1]}}</font>  |  <a href="#N_INT">&lang;INT&rang;</a> <font color="red">:#_INT_1</font>   <font color="red">{{A_Arg__M__h_INT[#_INT_1]}}</font>  )  |  (   "<code>[</code>"   <a href="#N_I_Arg">&lang;I_Arg&rang;</a> <font color="red">:#_I_Arg_1</font>    "<code>]</code>"   <font color="red">{{ A_Arg__M__5b_I_Arg__M__5d[#_I_Arg_1]}}</font>  |  (  <a href="#N_Name">&lang;Name&rang;</a> <font color="red">:#_Name_1</font>   <font color="red">{{A_Arg_Name[#_Name_1]}}</font>  |  <a href="#N_Tmp">&lang;Tmp&rang;</a> <font color="red">:#_Tmp_1</font>   <font color="red">{{A_Arg_Tmp[#_Tmp_1]}}</font>  )  )  ) 
 */
  final public net.sf.crsx.Sink N_A_Arg(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_A_Arg");
    try {
        net.sf.crsx.Sink bs___Tmp_1 = null;
        net.sf.crsx.Sink bs___Name_1 = null;
        Token t = null;
        net.sf.crsx.util.Buffer b___Name_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___I_Arg_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___FLOAT_1 = null;
        net.sf.crsx.util.Buffer b___Tmp_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___I_Arg_1 = null;
        net.sf.crsx.util.Buffer b___INT_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___INT_1 = null;
        net.sf.crsx.util.Buffer b___FLOAT_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_A_xArg:
        t = jj_consume_token(T_meta1_T_M_A_xArg);
                sink = sink .start(makeTConstructor(sink, t, unmeta(t.toString()), null)) ;
                {if (true) return sink .end() ;}
        break;
      case T_meta2_T_M_A_xArg:
        t = jj_consume_token(T_meta2_T_M_A_xArg);
                try {sink = factory.parser(factory).parse(sink, "firstRawSorted_A_Arg", new java.io.StringReader(unmeta(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta1_T_M_ID:
      case T_meta2_T_M_ID:
      case T_meta1_T_M_Name:
      case T_meta2_T_M_Name:
      case T_meta1_T_M_T:
      case T_meta2_T_M_T:
      case T_meta1_T_M_Tmp:
      case T_meta2_T_M_Tmp:
      case 112:
      case 113:
      case T_T_M_ID:
      case T_T_M_T:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 112:
          jj_consume_token(112);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case T_meta1_T_M_FLOAT:
          case T_meta2_T_M_FLOAT:
          case T_T_M_FLOAT:
                                bs___FLOAT_1 = b___FLOAT_1.sink();
            N_FLOAT(bs___FLOAT_1, env);
                                sink = sink .start(sink.makeConstructor("A_Arg__M__h_FLOAT")) .copy(b___FLOAT_1, true) .end() ;
            break;
          case T_meta1_T_M_INT:
          case T_meta2_T_M_INT:
          case T_T_M_INT:
                                bs___INT_1 = b___INT_1.sink();
            N_INT(bs___INT_1, env);
                                sink = sink .start(sink.makeConstructor("A_Arg__M__h_INT")) .copy(b___INT_1, true) .end() ;
            break;
          default:
            jj_la1[93] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        case T_meta1_T_M_ID:
        case T_meta2_T_M_ID:
        case T_meta1_T_M_Name:
        case T_meta2_T_M_Name:
        case T_meta1_T_M_T:
        case T_meta2_T_M_T:
        case T_meta1_T_M_Tmp:
        case T_meta2_T_M_Tmp:
        case 113:
        case T_T_M_ID:
        case T_T_M_T:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 113:
            jj_consume_token(113);
                                bs___I_Arg_1 = b___I_Arg_1.sink();
            N_I_Arg(bs___I_Arg_1, env);
            jj_consume_token(114);
                                sink = sink .start(sink.makeConstructor("A_Arg__M__5b_I_Arg__M__5d")) .copy(b___I_Arg_1, true) .end() ;
            break;
          case T_meta1_T_M_ID:
          case T_meta2_T_M_ID:
          case T_meta1_T_M_Name:
          case T_meta2_T_M_Name:
          case T_meta1_T_M_T:
          case T_meta2_T_M_T:
          case T_meta1_T_M_Tmp:
          case T_meta2_T_M_Tmp:
          case T_T_M_ID:
          case T_T_M_T:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case T_meta1_T_M_ID:
            case T_meta2_T_M_ID:
            case T_meta1_T_M_Name:
            case T_meta2_T_M_Name:
            case T_T_M_ID:
                                        bs___Name_1 = b___Name_1.sink();
              N_Name(bs___Name_1, env);
                                        sink = sink .start(sink.makeConstructor("A_Arg_Name")) .copy(b___Name_1, true) .end() ;
              break;
            case T_meta1_T_M_T:
            case T_meta2_T_M_T:
            case T_meta1_T_M_Tmp:
            case T_meta2_T_M_Tmp:
            case T_T_M_T:
                                        bs___Tmp_1 = b___Tmp_1.sink();
              N_Tmp(bs___Tmp_1, env);
                                        sink = sink .start(sink.makeConstructor("A_Arg_Tmp")) .copy(b___Tmp_1, true) .end() ;
              break;
            default:
              jj_la1[94] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[95] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[96] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[97] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_A_Arg");
    }
  }

/* Raw terms of A_Arg production sort. */

/** <em>Raw_A_Arg$WithEOF</em> ::= <em>Raw_A_Arg</em> EOF . */
  final public net.sf.crsx.Sink N_Raw_A_Arg$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_A_Arg$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_Raw_A_Arg(sink, env);
                                                                                                          token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_A_Arg$WithEOF");
    }
  }

/**
 * <em>Raw_A_Arg</em> ::=  (   <a href="#T_RAW_TOKEN_A_Arg">RAW_TOKEN_A_Arg</a>  )?   <a href="#N_RawPresorted_A_Arg">&lang;RawPresorted_A_Arg&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Raw_A_Arg(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Raw_A_Arg");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_A_Arg:
        jj_consume_token(T_RAW_TOKEN_A_Arg);
        break;
      default:
        jj_la1[98] = jj_gen;
        ;
      }
      sink = N_RawPresorted_A_Arg(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Raw_A_Arg");
    }
  }

/** <em>RawSorted_A_Arg$WithEOF</em> ::= <em>RawSorted_A_Arg</em> EOF . */
  final public net.sf.crsx.Sink N_RawSorted_A_Arg$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_A_Arg$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSorted_A_Arg(sink, env);
                                                                                                                token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                           {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_A_Arg$WithEOF");
    }
  }

/**
 * <em>RawSorted_A_Arg</em> ::=   <a href="#T_RAW_TOKEN_A_Arg">RAW_TOKEN_A_Arg</a>   <a href="#N_RawPresorted_A_Arg">&lang;RawPresorted_A_Arg&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSorted_A_Arg(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSorted_A_Arg");
    try {
        Token t = null;
      jj_consume_token(T_RAW_TOKEN_A_Arg);
      sink = N_RawPresorted_A_Arg(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSorted_A_Arg");
    }
  }

/** <em>RawPresorted_A_Arg$WithEOF</em> ::= <em>RawPresorted_A_Arg</em> EOF . */
  final public net.sf.crsx.Sink N_RawPresorted_A_Arg$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_A_Arg$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawPresorted_A_Arg(sink, env);
                                                                                                                   token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                              {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_A_Arg$WithEOF");
    }
  }

/**
 * <em>RawPresorted_A_Arg</em> ::=  <font color="red">{RAW-VariableUseSorted}</font>   (  <font color="red">{A_Arg}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-MetaApplicationSorted}</font>   (  <font color="red">{A_Arg}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{RAW-ConstructionSorted}</font>   (  <font color="red">{A_Arg}</font>  )   (  <font color="red">{RAW-RepeatSingle}</font>  )   (   <a href="#T_RAW_CONSTRUCTOR">RAW_CONSTRUCTOR</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawScopes">&lang;RawScopes&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |   <a href="#T_RAW_LPAREN">RAW_LPAREN</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawPresorted_A_Arg(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawPresorted_A_Arg");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUseSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "A_Arg", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_META_VARIABLE:
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplicationSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "A_Arg", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        default:
          jj_la1[99] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_RAW_CONSTRUCTOR:
                sink = sink .start(makeTConstructor(sink, t, "RAW-ConstructionSorted", null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "A_Arg", null)) ;
                        sink = sink .end() ;
                        sink = sink .start(makeTConstructor(sink, t, "RAW-RepeatSingle", null)) ;
                        sink = sink .end() ;
        t = jj_consume_token(T_RAW_CONSTRUCTOR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_LBRACKET:
          jj_consume_token(T_RAW_LBRACKET);
          sink = N_RawScopes(sink, env);
          jj_consume_token(T_RAW_RBRACKET);
          break;
        case T_RAW_LPAREN:
          jj_consume_token(T_RAW_LPAREN);
          sink = N_RawTerms(sink, env);
          jj_consume_token(T_RAW_RPAREN);
          break;
        default:
          jj_la1[100] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[101] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawPresorted_A_Arg");
    }
  }

/* Raw term entry points.
 * (1) a term is 'sorted'
 */

/** <em>RawTerms$WithEOF</em> ::= <em>RawTerms</em> EOF . */
  final public net.sf.crsx.Sink N_RawTerms$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawTerms$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawTerms(sink, env);
                                                                                                         token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                    {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawTerms$WithEOF");
    }
  }

/**
 * <em>RawTerms</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_RawTerm">&lang;RawTerm&rang;</a>    <a href="#N_RawTermsTail">&lang;RawTermsTail&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_RawTerms(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawTerms");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_Exp:
      case T_RAW_TOKEN_Name:
      case T_RAW_TOKEN_Stat:
      case T_RAW_TOKEN_Type:
      case T_RAW_TOKEN_I_Progr:
      case T_RAW_TOKEN_I_Instr:
      case T_RAW_TOKEN_I_Arg:
      case T_RAW_TOKEN_Tmp:
      case T_RAW_TOKEN_A_Progr:
      case T_RAW_TOKEN_A_Instr:
      case T_RAW_TOKEN_A_Arg:
      case T_RAW_VARIABLE:
      case T_RAW_META_VARIABLE:
      case T_RAW_CONSTRUCTOR:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_RawTerm(sink, env);
        sink = N_RawTermsTail(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[102] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawTerms");
    }
  }

/**
 * <em>RawTermsTail</em> ::=  <font color="red">{$Cons}</font>    <a href="#T_RAW_COMMA">RAW_COMMA</a>   <a href="#N_RawTerm">&lang;RawTerm&rang;</a>    <a href="#N_RawTermsTail">&lang;RawTermsTail&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_RawTermsTail(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawTermsTail");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_COMMA:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        jj_consume_token(T_RAW_COMMA);
        sink = N_RawTerm(sink, env);
        sink = N_RawTermsTail(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[103] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawTermsTail");
    }
  }

/** <em>RawTerm$WithEOF</em> ::= <em>RawTerm</em> EOF . */
  final public net.sf.crsx.Sink N_RawTerm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawTerm$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawTerm(sink, env);
                                                                                                        token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                   {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawTerm$WithEOF");
    }
  }

/**
 * <em>RawTerm</em> ::=  <a href="#N_RawSortedTerm">&lang;RawSortedTerm&rang;</a>   <br>
 *  |  <a href="#N_RawConstruction">&lang;RawConstruction&rang;</a>   <br>
 *  |  <a href="#N_RawVariableUse">&lang;RawVariableUse&rang;</a>   <br>
 *  |  <a href="#N_RawMetaApplication">&lang;RawMetaApplication&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawTerm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawTerm");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_Exp:
      case T_RAW_TOKEN_Name:
      case T_RAW_TOKEN_Stat:
      case T_RAW_TOKEN_Type:
      case T_RAW_TOKEN_I_Progr:
      case T_RAW_TOKEN_I_Instr:
      case T_RAW_TOKEN_I_Arg:
      case T_RAW_TOKEN_Tmp:
      case T_RAW_TOKEN_A_Progr:
      case T_RAW_TOKEN_A_Instr:
      case T_RAW_TOKEN_A_Arg:
        sink = N_RawSortedTerm(sink, env);
         {if (true) return sink;}
        break;
      case T_RAW_CONSTRUCTOR:
        sink = N_RawConstruction(sink, env);
         {if (true) return sink;}
        break;
      case T_RAW_VARIABLE:
        sink = N_RawVariableUse(sink, env);
         {if (true) return sink;}
        break;
      case T_RAW_META_VARIABLE:
        sink = N_RawMetaApplication(sink, env);
         {if (true) return sink;}
        break;
      default:
        jj_la1[104] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawTerm");
    }
  }

/** <em>RawSortedTerm$WithEOF</em> ::= <em>RawSortedTerm</em> EOF . */
  final public net.sf.crsx.Sink N_RawSortedTerm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSortedTerm$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawSortedTerm(sink, env);
                                                                                                              token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSortedTerm$WithEOF");
    }
  }

/**
 * <em>RawSortedTerm</em> ::=  <a href="#N_RawSorted_A_Arg">&lang;RawSorted_A_Arg&rang;</a>   <br>
 *  |  <a href="#N_RawSorted_Tmp">&lang;RawSorted_Tmp&rang;</a>   <br>
 *  |  <a href="#N_RawSorted_I_Instr">&lang;RawSorted_I_Instr&rang;</a>   <br>
 *  |  <a href="#N_RawSorted_A_Progr">&lang;RawSorted_A_Progr&rang;</a>   <br>
 *  |  <a href="#N_RawSorted_Stat">&lang;RawSorted_Stat&rang;</a>   <br>
 *  |  <a href="#N_RawSorted_Name">&lang;RawSorted_Name&rang;</a>   <br>
 *  |  <a href="#N_RawSorted_I_Arg">&lang;RawSorted_I_Arg&rang;</a>   <br>
 *  |  <a href="#N_RawSorted_Exp">&lang;RawSorted_Exp&rang;</a>   <br>
 *  |  <a href="#N_RawSorted_I_Progr">&lang;RawSorted_I_Progr&rang;</a>   <br>
 *  |  <a href="#N_RawSorted_A_Instr">&lang;RawSorted_A_Instr&rang;</a>   <br>
 *  |  <a href="#N_RawSorted_Type">&lang;RawSorted_Type&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawSortedTerm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawSortedTerm");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_A_Arg:
        sink = N_RawSorted_A_Arg(sink, env);
         {if (true) return sink;}
        break;
      case T_RAW_TOKEN_Tmp:
        sink = N_RawSorted_Tmp(sink, env);
         {if (true) return sink;}
        break;
      case T_RAW_TOKEN_I_Instr:
        sink = N_RawSorted_I_Instr(sink, env);
         {if (true) return sink;}
        break;
      case T_RAW_TOKEN_A_Progr:
        sink = N_RawSorted_A_Progr(sink, env);
         {if (true) return sink;}
        break;
      case T_RAW_TOKEN_Stat:
        sink = N_RawSorted_Stat(sink, env);
         {if (true) return sink;}
        break;
      case T_RAW_TOKEN_Name:
        sink = N_RawSorted_Name(sink, env);
         {if (true) return sink;}
        break;
      case T_RAW_TOKEN_I_Arg:
        sink = N_RawSorted_I_Arg(sink, env);
         {if (true) return sink;}
        break;
      case T_RAW_TOKEN_Exp:
        sink = N_RawSorted_Exp(sink, env);
         {if (true) return sink;}
        break;
      case T_RAW_TOKEN_I_Progr:
        sink = N_RawSorted_I_Progr(sink, env);
         {if (true) return sink;}
        break;
      case T_RAW_TOKEN_A_Instr:
        sink = N_RawSorted_A_Instr(sink, env);
         {if (true) return sink;}
        break;
      case T_RAW_TOKEN_Type:
        sink = N_RawSorted_Type(sink, env);
         {if (true) return sink;}
        break;
      default:
        jj_la1[105] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawSortedTerm");
    }
  }

/** <em>RawConstruction$WithEOF</em> ::= <em>RawConstruction</em> EOF . */
  final public net.sf.crsx.Sink N_RawConstruction$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawConstruction$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawConstruction(sink, env);
                                                                                                                token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                           {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawConstruction$WithEOF");
    }
  }

/**
 * <em>RawConstruction</em> ::=  <font color="red">{RAW-Construction}</font>   (   <a href="#T_RAW_CONSTRUCTOR">RAW_CONSTRUCTOR</a><font color="red">$</font>  )   (   <a href="#T_RAW_LPAREN">RAW_LPAREN</a>   <a href="#N_RawScopes">&lang;RawScopes&rang;</a>     <a href="#T_RAW_RPAREN">RAW_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawConstruction(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawConstruction");
    try {
        Token t = null;
                sink = sink .start(makeTConstructor(sink, t, "RAW-Construction", null)) ;
      t = jj_consume_token(T_RAW_CONSTRUCTOR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_LPAREN:
        jj_consume_token(T_RAW_LPAREN);
        sink = N_RawScopes(sink, env);
        jj_consume_token(T_RAW_RPAREN);
        break;
      default:
        jj_la1[106] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
      }
      sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawConstruction");
    }
  }

/** <em>RawVariableUse$WithEOF</em> ::= <em>RawVariableUse</em> EOF . */
  final public net.sf.crsx.Sink N_RawVariableUse$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawVariableUse$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawVariableUse(sink, env);
                                                                                                               token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                          {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawVariableUse$WithEOF");
    }
  }

/**
 * <em>RawVariableUse</em> ::=  <font color="red">{RAW-VariableUse}</font>   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">!!!</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawVariableUse(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawVariableUse");
    try {
        Token t = null;
        String s_RAW_VARIABLE = null;
        net.sf.crsx.Variable v_RAW_VARIABLE = null;
                sink = sink .start(makeTConstructor(sink, t, "RAW-VariableUse", null)) ;
      t = jj_consume_token(T_RAW_VARIABLE);
                        s_RAW_VARIABLE = t.toString();
                        v_RAW_VARIABLE = (env.containsKey(s_RAW_VARIABLE) ? env.get(s_RAW_VARIABLE) : factory.freeVariable(s_RAW_VARIABLE, true, true));
                        if (v_RAW_VARIABLE == null) {if (true) throw new ParseException("Variable "+s_RAW_VARIABLE+" cannot be resolved?");}
                        sink = sink .use(v_RAW_VARIABLE) ;
      sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawVariableUse");
    }
  }

/** <em>RawMetaApplication$WithEOF</em> ::= <em>RawMetaApplication</em> EOF . */
  final public net.sf.crsx.Sink N_RawMetaApplication$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawMetaApplication$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawMetaApplication(sink, env);
                                                                                                                   token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                              {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawMetaApplication$WithEOF");
    }
  }

/**
 * <em>RawMetaApplication</em> ::=  <font color="red">{RAW-MetaApplication}</font>   (   <a href="#T_RAW_META_VARIABLE">RAW_META_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawTerms">&lang;RawTerms&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawMetaApplication(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawMetaApplication");
    try {
        Token t = null;
                sink = sink .start(makeTConstructor(sink, t, "RAW-MetaApplication", null)) ;
      t = jj_consume_token(T_RAW_META_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_LBRACKET:
        jj_consume_token(T_RAW_LBRACKET);
        sink = N_RawTerms(sink, env);
        jj_consume_token(T_RAW_RBRACKET);
        break;
      default:
        jj_la1[107] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
      }
      sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawMetaApplication");
    }
  }

/** <em>RawScopes$WithEOF</em> ::= <em>RawScopes</em> EOF . */
  final public net.sf.crsx.Sink N_RawScopes$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawScopes$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawScopes(sink, env);
                                                                                                          token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawScopes$WithEOF");
    }
  }

/**
 * <em>RawScopes</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_RawScope">&lang;RawScope&rang;</a>    <a href="#N_RawScopesTail">&lang;RawScopesTail&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_RawScopes(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawScopes");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_TOKEN_Exp:
      case T_RAW_TOKEN_Name:
      case T_RAW_TOKEN_Stat:
      case T_RAW_TOKEN_Type:
      case T_RAW_TOKEN_I_Progr:
      case T_RAW_TOKEN_I_Instr:
      case T_RAW_TOKEN_I_Arg:
      case T_RAW_TOKEN_Tmp:
      case T_RAW_TOKEN_A_Progr:
      case T_RAW_TOKEN_A_Instr:
      case T_RAW_TOKEN_A_Arg:
      case T_RAW_VARIABLE:
      case T_RAW_META_VARIABLE:
      case T_RAW_CONSTRUCTOR:
      case T_RAW_LBRACKET:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_RawScope(sink, env);
        sink = N_RawScopesTail(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[108] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawScopes");
    }
  }

/**
 * <em>RawScopesTail</em> ::=  <font color="red">{$Cons}</font>    <a href="#T_RAW_COMMA">RAW_COMMA</a>   <a href="#N_RawScope">&lang;RawScope&rang;</a>    <a href="#N_RawScopesTail">&lang;RawScopesTail&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_RawScopesTail(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawScopesTail");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_COMMA:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        jj_consume_token(T_RAW_COMMA);
        sink = N_RawScope(sink, env);
        sink = N_RawScopesTail(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[109] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawScopesTail");
    }
  }

/** <em>RawScope$WithEOF</em> ::= <em>RawScope</em> EOF . */
  final public net.sf.crsx.Sink N_RawScope$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawScope$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawScope(sink, env);
                                                                                                         token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                    {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawScope$WithEOF");
    }
  }

/**
 * <em>RawScope</em> ::=  <font color="red">{RAW-Scope}</font>   (   <a href="#T_RAW_LBRACKET">RAW_LBRACKET</a>   <a href="#N_RawVariables">&lang;RawVariables&rang;</a>     <a href="#T_RAW_RBRACKET">RAW_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_RawTerm">&lang;RawTerm&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RawScope(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawScope");
    try {
        Token t = null;
                sink = sink .start(makeTConstructor(sink, t, "RAW-Scope", null)) ;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_LBRACKET:
        jj_consume_token(T_RAW_LBRACKET);
        sink = N_RawVariables(sink, env);
        jj_consume_token(T_RAW_RBRACKET);
        break;
      default:
        jj_la1[110] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
      }
      sink = N_RawTerm(sink, env);
                {if (true) return sink .end() ;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawScope");
    }
  }

/** <em>RawVariables$WithEOF</em> ::= <em>RawVariables</em> EOF . */
  final public net.sf.crsx.Sink N_RawVariables$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawVariables$WithEOF");
    try {
  int savedState = token_source.curLexState;
                                                token_source.SwitchTo(RAW);
      sink = N_RawVariables(sink, env);
                                                                                                             token_source.SwitchTo(savedState);
      jj_consume_token(0);
                                                                                                                                                        {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawVariables$WithEOF");
    }
  }

/**
 * <em>RawVariables</em> ::=  <font color="red">{$Cons}</font>   (   <a href="#T_RAW_VARIABLE">RAW_VARIABLE</a><font color="red">$</font>  )   (   <a href="#T_RAW_COMMA">RAW_COMMA</a>   <a href="#N_RawVariables">&lang;RawVariables&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_RawVariables(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawVariables");
    try {
        Token t = null;
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
      t = jj_consume_token(T_RAW_VARIABLE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_COMMA:
        jj_consume_token(T_RAW_COMMA);
        sink = N_RawVariables(sink, env);
        break;
      default:
        jj_la1[111] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
      }
                {if (true) return sink .end() ;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawVariables");
    }
  }

/**
 * <em>RawAttributes</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_RawAttribute">&lang;RawAttribute&rang;</a>    <a href="#N_RawAttributes">&lang;RawAttributes&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_RawAttributes(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawAttributes");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_UP:
      case T_RAW_DOWN:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_RawAttribute(sink, env);
        sink = N_RawAttributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[112] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawAttributes");
    }
  }

/**
 * <em>RawAttribute</em> ::=   <a href="#T_RAW_UP">RAW_UP</a>   (  <a href="#N_RawAttributeSynthesized_t">&lang;RawAttributeSynthesized_t&rang;</a>   )  <br>
 *  |   <a href="#T_RAW_DOWN">RAW_DOWN</a>   (  <a href="#N_RawAttributeInherited_e">&lang;RawAttributeInherited_e&rang;</a>   |  <a href="#N_RawAttributeInherited_TmpType">&lang;RawAttributeInherited_TmpType&rang;</a>   ) 
 */
  final public net.sf.crsx.Sink N_RawAttribute(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RawAttribute");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_RAW_UP:
        jj_consume_token(T_RAW_UP);
        sink = N_RawAttributeSynthesized_t(sink, env);
         {if (true) return sink;}
        break;
      case T_RAW_DOWN:
        jj_consume_token(T_RAW_DOWN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RAW_TOKEN_e:
          sink = N_RawAttributeInherited_e(sink, env);
          break;
        case T_RAW_TOKEN_TmpType:
          sink = N_RawAttributeInherited_TmpType(sink, env);
          break;
        default:
          jj_la1[113] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[114] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RawAttribute");
    }
  }

  /** Generated Token Manager. */
  public FirstParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[115];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
      jj_la1_init_5();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x42,0x0,0x0,0x0,0x2100,0x0,0x0,0x0,0x108000,0x0,0x0,0x0,0xa50a142,0x800000,0x1000000,0x10a100,0x10a142,0x210a142,0xa10a142,0x0,0x0,0x0,0x0,0x108000,0x0,0x0,0x0,0x0,0x108000,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x108000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x1800000,0x108000,0x108000,0x0,0x0,0x0,0x0,0x42,0x2142,0x10a142,0x10a142,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2142,0x108000,0x108000,0x108000,0x108000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x85,0x0,0x0,0x84,0x84,0x84,0x85,0x0,0x0,0x0,0x0,0x84,0x0,0x0,0x0,0x0,0x84,0x200,0x800,0x0,0x84000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4200000,0x0,0x0,0x0,0x4200084,0x200,0x20000000,0x10000000,0x40000000,0x0,0x0,0x0,0x0,0x2000,0x2000,0x4200084,0x4200084,0x0,0x0,0x0,0x0,0x4200000,0x4200000,0x4200084,0x4200084,0x0,0x0,0x0,0x0,0x4200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4200084,0x4200084,0x4200084,0x4200084,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2100840,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x2100000,0x2100840,0x0,0x0,0x0,0x0,0x2100000,0x2100000,0x2100000,0x2142000,0x0,0x0,0x0,0x0,0x2100000,0x0,0x0,0x0,0x0,0x0,0x10000000,0x8000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2100000,0x2100000,0x2100000,0x2100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x43d0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x180,0x1c0,0x1d0,0x43d0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x30000,0x10b0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x1000000,0x1,0x0,0xc0000000,0x2000000,0x2,0x0,0xc0000000,0x4000000,0x4,0x0,0xc0000000,0x7000000,0x0,0x0,0x6000000,0x7000000,0x7000000,0x7000000,0x8,0x0,0x0,0xc0000000,0x4000000,0x10,0x0,0x0,0xc0000000,0x4000000,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0xc0000000,0x40,0x0,0x0,0x0,0x0,0xc0000780,0x20000000,0x2000,0x0,0xc0000000,0x24000000,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0xc0000000,0x0,0x0,0x24000000,0x24000000,0x8000,0x0,0x0,0xc0000000,0x21000000,0x23000000,0x27000000,0x27000000,0x10000,0x0,0x0,0xc0000000,0x20000000,0x20000,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0xc0100000,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0xc0000000,0x3000000,0x24000000,0x24000000,0x24000000,0x24000000,0x400000,0x0,0x0,0xc0000000,0xc06bc078,0x0,0xc06bc078,0x6bc078,0x0,0x0,0xc06bc078,0x0,0x0,0x0,0x0,0x41000,0x0,};
   }
   private static void jj_la1_init_5() {
      jj_la1_5 = new int[] {0x0,0x0,0x8,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0xa,0x1,0x0,0x0,0x8,0xa,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0xa,0x1,0x0,0x8,0x2,0x2,0xa,0x1,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0xa,0x1,0x0,0x0,0x0,0x0,0x0,0x8,0xa,0x1,0x0,0x0,0x0,0x0,0x0,0x8,0xa,0x1,0x0,0x0,0x8,0xa,0x1,0x0,0x0,0x0,0x0,0x0,0x8,0xa,0x1,0x0,0x0,0x0,0x0,0x0,0x8,0xa,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0xa,0x1,0x1,0x80,0x1,0x0,0x2,0x8,0x9,0x80,0x8,0x80,0x600,0x0,0x600,};
   }

  /** Constructor with InputStream. */
  public FirstParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public FirstParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new FirstParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 115; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 115; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public FirstParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new FirstParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 115; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 115; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public FirstParser(FirstParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 115; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(FirstParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 115; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[173];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 115; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 173; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

/** Enable tracing. */
  final public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

}
