# Generic setup for HACS -*-Makefile-*-.
# $Id: Makefile-hx,v 1.20 2014/01/26 21:14:34 krisrose Exp $
# This file is used both for HACS installation and by the HACS user make system.

# Note: You should not need to modify anything in this file.
# If any of the following system commands are not right then
# set them correctly in your local Makefile.

# SYSTEM COMMANDS.
#
# These are suitable defaults for many systems. Adjust in your local Makefile.
#
JAVA = java
JAVAC = javac
JAR = jar
WGET = wget
UNZIP = unzip -q
CC = gcc -std=c99 -g -Wall
FLEX = flex

# Standard targets.
.PHONY: all clean realclean distclean setup
all::
clean::; rm -f *.tmp *~ ./#* *.log *~
realclean:: clean
distclean:: realclean

# Absolute paths.
DIR := $(abspath .)

# Build directory.
BUILD := $(DIR)/build
realclean::; rm -fr $(BUILD)

# How to run the build executables.
CRSXJAR = $(HACS)/crsx.jar
JAVACCJAR = $(HACS)/javacc-6.0/bin/lib/javacc.jar

CRSX = $(JAVA) -ea -cp "$(BUILD):$(CRSXJAR):" net.sf.crsx.run.Crsx allow-unnamed-rules $(EXTRA)
PG = $(JAVA) -cp "$(BUILD):$(CRSXJAR):$(JAVACCJAR):" net.sf.crsx.pg.PG $(EXTRA)
JAVACC = $(JAVA) -cp "$(JAVACCJAR)" javacc
RULEC = $(HACS)/rulecompiler/crsx
COOK = $(HACS)/Cookmain

all:: $(RULEC) $(COOK)

# So -n works...
NOEXEC = $(if,$(findstring -n,$(MAKE)),echo)
SH_EXTRA = :


# =====================
# HACS GENERATION RULES
# =====================

.SECONDARY:

# 1. Parse .hx to get .hxg simple term grammar version (with unparsed rules).
#
# Runs Java with crsx.jar embedded Raw+Text parsers.
#
%.hxg : %.hx
	@/bin/echo '* PROCESSING $< TO $@ (STEP 1 OF 8).'
	@: set -x \
	&& $(NOEXEC) $(CRSX) \
		"grammar=('org.crsx.hacs.Raw';'net.sf.crsx.text.Text';)" \
		input='$<' category=rawModule \
		output='$@.tmp' simple-terms max-indent=10 width=255
	@mv '$@.tmp' '$@'

clean::; rm -f *.tmp *.hxg

# 2. Rewrite .hxg to .pg meta-parser (for user's notation in PG tool notation).
#
# Runs Java with crsx.jar on Cook.crs(wrapper=PG).
# TODO: revive and use compiled Cookmain.
# TODO2: Directly generate JavaCC or some other parser generator.
#
%.pg : %.hxg
	@/bin/echo '* PROCESSING $< TO $@ (STEP 2 OF 8).'
	@: set -x \
	&& $(NOEXEC) $(CRSX) \
		rules=org/crsx/hacs/Cook.crs wrapper=PG \
		input='$<' \
		output='$@.tmp' sink=net.sf.crsx.text.TextSink
	@mv '$@.tmp' '$@'

clean::; rm -f *.tmp *.pg

# 3. Install .pg into Java environment.
#
# Runs PG (from crsx.jar), JavaCC, and javac, to generate parser Java classes in build/ directory.
#
%.pg-installed : %.pg $(JAVACCJAR)
	@/bin/echo -e '* GENERATING AND COMPILING JavaCC PARSER FOR $< (STEP 3 OF 8).'
	@: set -x \
	&& $(NOEXEC) class=$$(sed -n 's/^class \(.*\)Parser :.*/\1/p' '$*.pg') \
	&& $(NOEXEC) base=$$(echo $$class | sed 's:\.:/:g') \
	&& $(NOEXEC) mkdir -p $(BUILD)/$$(dirname $$base) \
	&& $(NOEXEC) dir=`pwd` \
	&& (test '$*.pg' -ot $(BUILD)/$${base}Parser.pg || $(NOEXEC) cp -v '$*.pg' $(BUILD)/$${base}Parser.pg) \
	&& (test '$*.pg' -ot $(BUILD)/$${base}Parser.jj || $(NOEXEC) $(PG) '$*.pg' -source=$(BUILD)) \
	&& (cd $(BUILD) && ((test $${base}Parser.jj -ot $${base}Parser.java && $(NOEXEC) touch '$@.tmp') \
			     || ($(NOEXEC) $(JAVACC) -OUTPUT_DIRECTORY=$$(dirname $$base) $${base}Parser.jj > $$dir/'$@.tmp'))) \
	&& (cd $(BUILD) && (test $${base}Parser.java -ot $(BUILD)/$${base}Parser.class \
			    || ( $(NOEXEC) $(JAVAC) -cp '$(BUILD):$(CRSXJAR):$(JAVACCJAR)' -sourcepath $(BUILD) -d $(BUILD) $${base}Parser.java)))
	@mv '$@.tmp' '$@'

clean::; rm -f *.tmp *.pg-installed

# 4. Reprocess .hx and rewrite to .hxr with parsed rules (simple terms)
#
# Runs Java with crsx.jar on Prep.crs(wrapper=Prep) to emit complete simple term version of the .hx file.
# 
%.hxr : %.hx %.pg %.pg-installed
	@/bin/echo '* PROCESSING $< TO $@ (STEP 4 OF 8).'
	@: set -x \
	&& $(NOEXEC) parser=$$(sed -n 's/^class \(.*\) :.*/\1/p' '$*.pg') \
	&& $(NOEXEC) $(CRSX) \
		"grammar=('org.crsx.hacs.Raw';'net.sf.crsx.text.Text';'$$parser';)" raw \
		rules=org/crsx/hacs/Prep.crs wrapper=Prep \
		input='$<' category=rawModule \
		output='$@.tmp'
	@mv '$@.tmp' '$@'

clean::; rm -f *.tmp *.hxr

# 5. Rewrite .hxr to user's .crs.
#
# Runs Java with crsx.jar on Cook.crs(wrapper=CRS) to generate stand-alone .crs system.
# TODO: revive and use compiled Cookmain.
#
%.crs : %.hxr
	@/bin/echo '* PROCESSING $< TO $@ (STEP 5 OF 8).'
	@: set -x \
	&& $(NOEXEC) $(CRSX) \
		rules=org/crsx/hacs/Cook.crs wrapper=CRS \
		input='$<' \
		output='$@.tmp' sink=net.sf.crsx.text.TextSink
	@mv '$@.tmp' '$@'

realclean::; rm -f *.crs

# 6. Expand .crs to stand-alone simple-terms .crsE.
#
%.crsE: %.crs %.pg %.pg-installed
	@/bin/echo '* EXPANDING $< TO $@ (STEP 6 OF 8).'
	@: set -x \
	&& $(NOEXEC) parser=$$(sed -n 's/^class \(.*\) :.*/\1/p' '$*.pg') \
	&& $(NOEXEC) $(CRSX) rules='$<' \
		"grammar=('org.crsx.hacs.Raw';'net.sf.crsx.text.Text';'$$parser';)" \
		dump-rules='$@.tmp'
	@mv '$@.tmp' '$@'

clean::; rm -f *.crsE

# 7. Install .crs(E) into Java environment.
#
# Move .crs(E) into class hierarchy so it can be found as a resource.
# TODO: Upgrade to "rule-compile" generated .crs to proper binary.
#
%.crs-installed: %.crsE %.pg %.pg-installed
	@/bin/echo '* INSTALLING $< (STEP 7 OF 8).'
	@: set -x \
	&& $(NOEXEC) class=$$(sed -n 's/^class \(.*\)Parser :.*/\1/p' '$*.pg') \
	&& $(NOEXEC) base=$$(echo $$class | sed 's:\.:/:g') \
	&& $(NOEXEC) mkdir -p $(BUILD)/$$(dirname $$base) \
	&& (test '$<' -ot $(BUILD)/$${base}Rules.crs || $(NOEXEC) cp -v '$<' $(BUILD)/$${base}Rules.crs)
	@:
	@touch $@

realclean::; rm -f *.crs-installed

# 8. Generate .run script for user's .crs.
#
%.run: %.crs-installed %.pg %.pg-installed
	@/bin/echo '* GENERATING CUSTOM COMPILATION SCRIPT $@ (STEP 8 OF 8).'
	@: set -x \
	&& $(NOEXEC) class=$$(sed -n 's/^class \(.*\)Parser :.*/\1/p' '$*.pg') \
	&& $(NOEXEC) prefix=$$(sed -n 's/^prefix //p' '$*.pg') \
	&& $(NOEXEC) base=$$(echo $$class | sed -e 's:\.:/:g') \
	&& $(NOEXEC) mkdir -p $(BUILD)/$$(dirname $$base) \
	&& (echo exec env "JAVA='$(JAVA)'" "JAVAC='$(JAVAC)'" "CRSXJAR='$(CRSXJAR)'" \
			"HACSBUILD='$(BUILD)'" "HACSPARSERCLASS='$${class}Parser'" "HACSRULES='$(BUILD)/$${base}Rules.crs'" \
			"HACSPREFIX='$$prefix'" \
			'$(HACS)/run-hacs.sh' '"$$@"' > '$@.tmp')
	@mv '$@.tmp' '$@'
	chmod +x $@

realclean::; rm -f *.run


# ===========
# SETUP RULES
# ===========

# Retrieve and install JavaCC.
$(JAVACCJAR):
	@/bin/echo -e '\n* Retrieve and install JavaCC.'
	cd $(HACS) && $(WGET) https://java.net/projects/javacc/downloads/download/javacc-6.0.zip
	cd $(HACS) && $(UNZIP) javacc-6.0.zip && rm -f javacc-6.0.zip

distclean::; rm -fr $(HACS)/javacc*

TMP = $(DIR)/tmp

# Unpack support files from CRSX jar.
crsx.h crsx.c crsx_scan.l: $(CRSXJAR)
	@/bin/echo '** Extract C helper files from crsx.jar...'
	@rm -fr $(TMP)
	@mkdir -p $(TMP)
	(cd $(TMP) && $(JAR) xf $(CRSXJAR) net/sf/crsx/compiler/c/crsx.h net/sf/crsx/compiler/c/crsx.c net/sf/crsx/compiler/c/crsx_scan.l)
	@cp -v $(TMP)/net/sf/crsx/compiler/c/crsx.h crsx.h
	@cp -v $(TMP)/net/sf/crsx/compiler/c/crsx.c crsx.c
	@cp -v $(TMP)/net/sf/crsx/compiler/c/crsx_scan.l crsx_scan.l
	@rm -fr $(TMP)

$(RULEC): $(CRSXJAR)
	@/bin/echo '** Extracting and compiling rulecompiler...'
	@rm -fr $(HACS)/rulecompiler
	@mkdir -p $(TMP)
	(cd $(HACS) && $(JAR) xf $(CRSXJAR) rulecompiler)
	$(MAKE) -C $(HACS)/rulecompiler crsx

crsx_scan.o: crsx_scan.c crsx.h
crsx_scan.c: crsx_scan.l
	$(FLEX) -v -s -o crsx_scan.c crsx_scan.l
clean::; rm -f crsx_scan.c

realclean::; rm -fr crsx.h crsx.c crsx_scan.l $(HACS)/rulecompiler


# Build HACS 'Cook' utility.
$(COOK): $(CRSXJAR)
	$(MAKE) -C $(HACS) Cookmain


## Debugging helpers.

%.crsE: %.crs %.pg-installed
	@set -x \
	&& $(NOEXEC) parser=$$(sed -n 's/^class \(.*\) :.*/\1/p' '$*.pg') \
	&& $(NOEXEC) $(CRSX) grammar='("'$$parser'";"net.sf.crsx.text.Text";)' rules='$*.crs' dump-rules=$@.tmp \
	&& $(NOEXEC) mv '$@.tmp' '$@'

%.crsD: %.crs %.pg-installed
	@set -x \
	&& $(NOEXEC) parser=$$(sed -n 's/^class \(.*\) :.*/\1/p' '$*.pg') \
	&& $(NOEXEC) $(CRSX) grammar='("'$$parser'";"net.sf.crsx.text.Text";)' rules='$*.crs' sortify dispatchify dump-rules=$@.tmp \
	&& $(NOEXEC) mv '$@.tmp' '$@'

realclean::; rm -f *.crsE *.crsD

Prep.crsE :
	@set -x \
	&& $(NOEXEC) $(CRSX) \
		"grammar=('org.crsx.hacs.Raw';'net.sf.crsx.text.Text';)" \
		rules=org/crsx/hacs/Prep.crs wrapper=Prep \
		dump-rules=Prep.crsE
