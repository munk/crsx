// $Id: CookPG.crs,v 1.48 2014/01/26 21:14:39 krisrose Exp $
// CRSX3 RULES FOR CONVERTING RAW HACS FORMAT TO PG FORMAT.
//
// Rewrite to generate native JavaCC/Yacc/...!
//
CookPG[(

// Normalization and normalized structure (includes base library).
$Use["net/sf/crsx/hoacs/bootstrap/CookN.crs"];

// Insert options automatically.
$Lax;


/////////////////////////////////////////////////////////////////////
// TOP LEVEL
//
// Module morphed to function that normalizes and emits as PG.

PG[RawModule] :: Text;
PG[%rawModule⟦ module #ModuleName# { #Declarations# } ⟧]
→
PG1[#ModuleName#, N-resolve[#Declarations#]]
;

PG1[$String, RawDeclarations] :: Text;
PG1[#Name#, #Declarations#]
→
PG2[{} N-Declarations[#Declarations#, #Name#], FullName[#Name#], ParsePrefix[#Name#], #Declarations#]
;


/////////////////////////////////////////////////////////////////////
// TEXT OF PG GRAMMAR.
//
// Main entry point for generating CRSX3 PG grammar specification for normalized HACS specification.
//
// Uses three passes:
// a. Generate text of names of exported productions.
// b. Generate text of productions.
// c. Generate text of lexical declarations.

PG2[NormalizedSortMap, $String<!--JavaModuleName-->, $String<!--ParsePrefix-->, RawDeclarations] :: Text ;
PG2[{#ND}NSM[#SortNames], #Name, #ParsePrefix, #Declarations]
→
PG3[{#ND}NSM[#SortNames], #Name, #ParsePrefix, #Declarations, {#ND} DerivedSorts[#SortNames]]
;

PG3[NormalizedSortMap, $String<!--JavaModuleName-->, $String<!--ParsePrefix-->, RawDeclarations, $List[DERIVED_SORT]] :: Text ;
-[Data[#Name,#ParsePrefix,#Declarations,#Derived]]:
PG3[{#ND}NSM[#SortNames], #Name, #ParsePrefix, #Declarations, #Derived]
→
%n⟪/** PG Grammar for HACS module †« #Name ».
 * @version $Id: CookPG.crs,v 1.48 2014/01/26 21:14:39 krisrose Exp $
 */

class †«#Name»Parser : ⟦«
  TextFold[Map[s.%n⟨<†‹s›>⟩, {#ND}ProductionNames[NameSetList[#SortNames]]], %n⟨,⟩]
»«
  TextFold[Map[p.%n⟨,<†‹p›>⟩, NameSetList[Fold[x z.AddName[z, x], Map[d.TextToString[ProductionNameDerived[d]], #Derived], NoNames]]], %n⟨⟩]
»⟧
prefix †«#ParsePrefix»
declarations
%{
static String unmeta(String s, int i) {String inner = s.substring(1, s.length()-1).trim(); return (inner.length() > i ? inner.substring(i) : inner).trim();}
%}

/* GRAMMAR. */
« {#ND} PG-Productions[#SortNames] »

« TextFoldMap[JoinMappedTextMaps[d.PG-ProduceDerived[d], #Derived], %n⟨
⟩] »
/* TOKENS. */

%{
TOKEN_MGR_DECLS : { int nested_counter; } /* Used by all nesting constructs. */
%}

« PG-Lexical[#Declarations] »
⟫
;

// Only include productions for tokens and sorts that have syntax.

{$String<!--SortName--> : SortEntry} ProductionNames[$List[$String]] :: $List[$String];
{#ND}ProductionNames[()] → () ;
{#ND}ProductionNames[(#1;#s)] → {#ND}ProductionNames2[$[{#ND}Get[SortEntry],#1,SE_NONE], #1, #s] ;

{$String<!--SortName--> : SortEntry} ProductionNames2[SortEntry, $String, $List[$String]] :: $List[$String];
{#ND}ProductionNames2[SE_NONE, #1, #s] → {#ND}ProductionNames[#s] ;
{#ND}ProductionNames2[SE_TOKEN[#SortName], #1, #s] → (#1 ; {#ND}ProductionNames[#s]) ;
{#ND}ProductionNames2[SE_ATTRIBUTE[#Kind, #Name, #AttributeForm, #AttributeOptions], #1, #s] → {#ND}ProductionNames[#s] ;
{#ND}ProductionNames2[SE_SORT[#Defines, #SortName, #Precs, #Wrapper], #1, #s] → {#ND}ProductionNames3[#Defines, #1, #s] ;

{$String<!--SortName--> : SortEntry} ProductionNames3[$List[Define], $String, $List[$String]] :: $List[$String];
-[Fresh[dummy::RawSortParam]]:
{#ND} ProductionNames3[(D_ABSTRACTION[a.#Define1[a]]; #Defines), #1, #s] → {#ND} ProductionNames3[(#Define1[dummy]; #Defines), #1, #s] ;
{#ND} ProductionNames3[(D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #1, #s] → {#ND} ProductionNames3[#Defines, #1, #s] ;
{#ND} ProductionNames3[(D_FORM[#Form1, #Kind1]; #Defines), #1, #s] → {#ND} ProductionNames4[#Form1, #Defines, #1, #s] ;
{#ND} ProductionNames3[(D_NONE; #Defines), #1, #s] → {#ND} ProductionNames3[#Defines, #1, #s] ;
{#ND} ProductionNames3[(), #1, #s] → {#ND}ProductionNames[#s] ;

{$String<!--SortName--> : SortEntry} ProductionNames4[RawForm, $List[Define], $String, $List[$String]] :: $List[$String];
{#ND} ProductionNames4[RAW-FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Defines, #1, #s] → (#1; {#ND}ProductionNames[#s]) ;
{#ND} ProductionNames4[RAW-FormParsedUnsorted[#ParsedForm1, #Prec1, #InheritedRefs], #Defines, #1, #s] → (#1; {#ND}ProductionNames[#s]) ;
{#ND} ProductionNames4[RAW-FormConstruction[#Constructor, #ScopeSorts, #InheritedRefs], #Defines, #1, #s] → {#ND} ProductionNames3[#Defines, #1, #s] ;


/////////////////////////////////////////////////////////////////////
// TEXT OF ALL PRODUCTIONS.
//
// Productions are extracted by sort and for each sort grouped by precedence,
// each group producing a PG production.

{$String<!--SortName--> : SortEntry} PG-Productions[NameSet] :: Text;
{#ND} PG-Productions[#SortNames] → {#ND} PG-Productions1[HasNames[#SortNames], #SortNames] ;

{$String<!--SortName--> : SortEntry} PG-Productions1[Boolean, NameSet] :: Text;
{#ND} PG-Productions1[B_TRUE , #SortNames] → %n⟪« {#ND} PG-Production[FirstName[#SortNames]] »« {#ND} PG-Productions[RemoveFirstName[#SortNames]] »⟫ ;
{#ND} PG-Productions1[B_FALSE, #SortNames] → %n⟪⟫ ;

{$String<!--SortName--> : SortEntry} PG-Production[$String] :: Text;
-[Data[#SortName]]:
{#ND} PG-Production[#SortName] 
→
{#ND} PG-Production1[$[{#ND}Get, #SortName, SE_NONE]]
;

{$String<!--SortName--> : SortEntry} PG-Production1[SortEntry] :: Text;

{#ND} PG-Production1[SE_NONE]
→
%n⟪⟫
;

{#ND} PG-Production1[SE_TOKEN[#SortName]]
→
%n⟪
/* Productions for †«#SortName» token. */
<«ProductionName[#SortName]»> ::= « PG-MetaHead[B_TRUE, #SortName, #SortName, B_FALSE, 0] »«TokenName[#SortName]»$ .
« PG-MetaTail[B_TRUE, #SortName, #SortName] »⟫
;

{#ND} PG-Production1[SE_ATTRIBUTE[#Kind, #Name, #AttributeForm, #AttributeOptions]]
→
PG-Production-Attribute[#Kind, #Name, #AttributeForm, #AttributeOptions]
;

{#ND} PG-Production1[SE_SORT[#Defines, #SortName, #Precs, #Wrapper]]
→
{#ND} PG-Production-Defines[#Defines, #SortName, 0, ()]
;

// Handle an attribute definition.

PG-Production-Attribute[RawAttributeKind, $String, RawAttributeForm, $List[RawAttributeOption]] :: Text;
PG-Production-Attribute[#Kind, #Name, #AttributeForm, #AttributeOptions]
→
%n⟪⟫
;

// Handle a sort definition.

{$String<!--SortName--> : SortEntry} PG-Production-Defines[$List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

// Helper for ParsedForm and FK.
PFK_SORT ::=( PFK[RawParsedForm, FormKind]; );

{#ND} PG-Production-Defines[(), #SortName, #Prec, ()]
→
%n⟪⟫
;

{#ND} PG-Production-Defines[(), #SortName, #Prec, (#PFK1;#PFKs)]
→
%n⟪
/* Productions for †«#SortName» sort with (highest) precedence †«$[FormatNumber,#Prec]». */
« {#ND} PG-Expand[(#PFK1;#PFKs), #SortName, #Prec, B_TRUE] »⟫
;

-[Fresh[dummy::RawSortParam]]:
{#ND} PG-Production-Defines[(D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#ND} PG-Production-Defines[(#Define1[dummy]; #Defines), #SortName, #Prec, #PrecPFKs]
;

{#ND} PG-Production-Defines[(D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#ND} PG-Production-Defines[#Defines, #SortName, #Prec, #PrecPFKs]
;

{#ND} PG-Production-Defines[(D_FORM[#Form1, #Kind1]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#ND} PG-Production-Defines2[#Form1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#ND} PG-Production-Defines[(D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#ND} PG-Production-Defines[#Defines, #SortName, #Prec, #PrecPFKs]
;

{$String<!--SortName--> : SortEntry} PG-Production-Defines2[RawForm, FormKind, $List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

{#ND} PG-Production-Defines2[RAW-FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#ND} PG-Production-Defines3[#ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#ND} PG-Production-Defines2[RAW-FormParsedUnsorted[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#ND} PG-Production-Defines3[#ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#ND} PG-Production-Defines2[RAW-FormConstruction[#Constructor, #ScopeSorts, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#ND} PG-Production-Defines[#Defines, #SortName, #Prec, #PrecPFKs]
;

{$String<!--SortName--> : SortEntry} PG-Production-Defines3[RawParsedForm, $Numeric, FormKind, $List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

-[Data[#Prec1,#Prec],Share[#ParsedForm1,#Kind1,#Defines]]:
{#ND} PG-Production-Defines3[#ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, ()]
→
$[If, $[NumericEqual,#Prec1,#Prec],
  {#ND} PG-Production-Defines[#Defines, #SortName, #Prec, (PFK[#ParsedForm1, #Kind1];)],
  %n⟪
<«ProductionNameWithPrec[#SortName,#Prec]»> ::= <«ProductionNameWithPrec[#SortName,#Prec1]»> .
« {#ND} PG-Production-Defines[#Defines, #SortName, #Prec1, (PFK[#ParsedForm1, #Kind1];)] »⟫]
;

-[Data[#Prec1,#Prec],Share[#ParsedForm1,#Kind1,#Defines,#PFK,#PFKs]]:
{#ND} PG-Production-Defines3[#ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, (#PFK;#PFKs)]
→
$[If, $[NumericEqual,#Prec1,#Prec],
  {#ND} PG-Production-Defines[#Defines, #SortName, #Prec, Append[(#PFK;#PFKs), (PFK[#ParsedForm1, #Kind1];)]],
  %n⟪/* Productions for †«#SortName» sort with precedence †«$[FormatNumber,#Prec]». */
« {#ND} PG-Expand[(#PFK;#PFKs), #SortName, #Prec, B_FALSE] »
« {#ND} PG-Production-Defines[#Defines, #SortName, #Prec1, (PFK[#ParsedForm1, #Kind1];)] »
⟫]
;


/////////////////////////////////////////////////////////////////////
// TEXT OF SINGLE SORT+PRECEDENCE PRODUCTION EXPANSION.
//
// Emits the left recursion handler, if any, and the PG grammar production
// for the sort+precedence combination, with left factored buffering.

CONSUMPTION_SORT ::=( C_BUFFER[$String<!--SortName-->, $Numeric<!--precedence-->]; C_LEFTRECURSIVE[$String<!--SortName-->, $Numeric<!--precedence-->]; <!--C_INLINE;--> );
/// C_INLINE DISABLED.

{$String<!--SortName--> : SortEntry} PG-Expand[$List[PFK_SORT], $String, $Numeric, Boolean] :: Text;
{#ND} PG-Expand[#PrecPFKs, #SortName, #Prec, #Last?]
→
{#ND} PG-LeftRecursive[#PrecPFKs, #SortName, #Prec, #Last?, (), ()]
;

// Generate optional left recursion production helper, normal production, and optional meta-production.

{$String<!--SortName--> : SortEntry} PG-LeftRecursive[$List[PFK_SORT], $String, $Numeric, Boolean, $List[PFK_SORT], $List[PFK_SORT]] :: Text;
{$String<!--SortName--> : SortEntry} PG-LeftRecursive2[Boolean, PFK_SORT, $List[PFK_SORT], $String, $Numeric, Boolean, $List[PFK_SORT], $List[PFK_SORT]] :: Text;

{#ND} PG-LeftRecursive[(#PFK1; #PFKs), #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#ND} PG-LeftRecursive2[PG-isLeftRecursive[#SortName, #Prec, #PFK1], #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
;

{#ND} PG-LeftRecursive2[B_TRUE, #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#ND} PG-LeftRecursive[#PFKs, #SortName, #Prec, #Last?, Append[#LeftRecursivePFKs, (PG-stripLeftRecursion[#PFK1];)], #OtherPFKs]
;

{#ND} PG-LeftRecursive2[B_FALSE, #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#ND} PG-LeftRecursive[#PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, Append[#OtherPFKs, (#PFK1;)]]
;

{#ND} PG-LeftRecursive[(), #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
IfEmpty[#LeftRecursivePFKs,
  // There is no left recursion -- use the plain expansion.
  {#ND} PG-Produce[#SortName, #Prec, #Last?, #OtherPFKs, C_BUFFER[#SortName, #Prec]],
  // There is left recursion...
  {#ND} PG-ProduceBody[#LeftRecursivePFKs, 2, (%n⟨#1⟩;), (%n⟨LR⟩;), C_LEFTRECURSIVE[#SortName, #Prec], in after .
    %n⟪/* Handle left recursion. */
<«ProductionNameWithPrec[#SortName,#Prec]»LR #1> ::= ⟦«in»
| {{#1}}⟧
.
« TextFoldMap[after, %n⟨
⟩] »
« {#ND} PG-Produce[#SortName, #Prec, #Last?, #OtherPFKs, C_LEFTRECURSIVE[#SortName, #Prec]] »⟫]]
;

{$String<!--SortName--> : SortEntry} PG-Produce[$String, $Numeric, Boolean, $List[PFK_SORT], CONSUMPTION_SORT] :: Text;

{#ND} PG-Produce[#SortName, #Prec, #Last?, #PFKs, C_LEFTRECURSIVE[#SortName9, #Prec9]]
→
{#ND} PG-ProduceBody[#PFKs, 1, (), (), C_LEFTRECURSIVE[#SortName9, #Prec9], in after .
  %n⟪
<«ProductionNameWithPrec[#SortName,#Prec]»> ::= ⟦« PG-MetaHead[#Last?, #SortName, #SortName, B_TRUE, #Prec] »«in»⟧ .
« PG-MetaTail[#Last?, #SortName, #SortName] »« TextFoldMap[after, %n⟨
⟩] »⟫]
;

-[Data[#consumer]]:
{#ND} PG-Produce[#SortName, #Prec, #Last?, #PFKs, $[NotMatch,C_LEFTRECURSIVE[#_SortName, #_Prec],#consumer]]
→
{#ND} PG-ProduceBody[#PFKs, 1, (), (), #consumer, in after .
  %n⟪
<«ProductionNameWithPrec[#SortName,#Prec]»> ::= ⟦« PG-MetaHead[#Last?, #SortName, #SortName, B_FALSE, #Prec] »«in» .⟧ 
« PG-MetaTail[#Last?, #SortName, #SortName] »« TextFoldMap[after, %n⟨
⟩] »⟫]
;

///PG-MetaHead[#dontcare, #SortName, #Name, #isLeftRecursive, #Prec] → %n⟪⟫ ;
///PG-MetaTail[#dontcare, #SortName, #Name] → %n⟪⟫ ;

PG-MetaHead[Boolean, $String, $String, Boolean, $Numeric] :: Text;

PG-MetaHead[B_FALSE, #SortName, #Name, #isLeftRecursive, #Prec] → %n⟪⟫ ;

-[Data[#SortName],Discard[#Prec]]:
PG-MetaHead[B_TRUE, #SortName, #Name, B_FALSE, #Prec] →
 %n⟪ meta1_«TokenName[#Name] »$$:%{unmeta(#,0)%} | meta2_«TokenName[#Name]»$$:%{unmeta(#,†«$[FormatNumber,$[Length,#SortName]]»)%}
| ⟫ ;

-[Data[#SortName]]:
PG-MetaHead[B_TRUE, #SortName, #Name, B_TRUE, #Prec] →
 %n⟪ meta1_«TokenName[#Name]»$$:%{unmeta(#,0)%}:#1 <« ProductionNameWithPrec[#SortName, #Prec] »LR #1>
| meta2_«TokenName[#Name]»$$:%{unmeta(#,†«$[FormatNumber,$[Length,#SortName]]»)%}:#1 <« ProductionNameWithPrec[#SortName,#Prec] »LR #1>
| ⟫ ;

PG-MetaTail[Boolean, $String, $String] :: Text;

PG-MetaTail[B_FALSE, #SortName, #Name] → %n⟪⟫ ;

-[Data[#SortName]]: PG-MetaTail[B_TRUE, #SortName, #Name] → %n⟪
%{
TOKEN : { < T_meta1_«TokenName[#Name]» : ("\u27e8" (" ")* †« Stringify[#SortName] » (" ")* "\u27e9") > }
MORE : { < "\u27e8" (" ")* †« Stringify[#SortName] » (" ")* ~["\u27e9"] > { nested_counter = 0; } : IN_META_«TokenName[#Name]»}
<IN_META_«TokenName[#Name]»,IN_NESTED_META_«TokenName[#Name]»> MORE : { "\u27e8" { nested_counter++; } : IN_NESTED_META_«TokenName[#Name]» }
<IN_NESTED_META_«TokenName[#Name]»> MORE : { "\u27e9" { if (--nested_counter <= 0) SwitchTo(IN_META_«TokenName[#Name]»); } }
<IN_META_«TokenName[#Name]»> TOKEN : { < T_meta2_«TokenName[#Name]» : "\u27e9" > : DEFAULT }
<IN_META_«TokenName[#Name]»,IN_NESTED_META_«TokenName[#Name]»> MORE : { < ~[] > }
%}
⟫ ;

{$String<!--SortName--> : SortEntry} PG-ProduceBody[$List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#PFKs]]:
{#ND} PG-ProduceBody[#PFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBody1[#PFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;
/// C_INLINE DISABLED.
///
///-[Data[#PFKs]]:
///{#ND} PG-ProduceBody[#PFKs, #n, #terms, #words, C_BUFFER[#SortName, #Prec], in after . #[in,after]]
///→
///IfSingleton[#PFKs,
///  // Only choice so output constructor and buffered arguments now!
///  {#ND} PG-ProduceBody1[#PFKs, #n, #terms, #words, C_INLINE, in after .
///    #[IfAlias[#PFKs,
///      %n⟪« WrappedTextFold[#terms, %n⟨{{⟩, %n⟨}} {{⟩, %n⟨}}⟩] »«in»⟫,
///      %n⟪ {'« ProductionNameWithPrec[#SortName, #Prec] »« TextFold1[#words, %n⟨_⟩] »_inline'} « WrappedTextFold[#terms, %n⟨{{⟩, %n⟨}} {{⟩, %n⟨}} ⟩] »«in»⟫],
///    after]],
///  // Non-singleton PFKs so we continue buffering.
///  {#ND} PG-ProduceBody1[#PFKs, #n, #terms, #words, C_BUFFER[#SortName, #Prec], in after . #[in,after]]
///]
///;
///
///IfAlias[(), #1, #2] → #2 ;
///IfAlias[(PFK[#PF1, #PK1]; #PFKs), #1, #2] → IfAliasKind[#PK1, #1, #2] ;
///
///{#ND} PG-ProduceBody[#PFKs, #n, #terms, #words, C_INLINE, in after . #[in,after]]
///→
///{#ND} PG-ProduceBody1[#PFKs, #n, #terms, #words, C_INLINE, in after . #[in,after]]
///;
///
///{#ND} PG-ProduceBody[#PFKs, #n, #terms, #words, C_LEFTRECURSIVE[#SortName, #Prec], in after . #[in,after]]
///→
///{#ND} PG-ProduceBody1[#PFKs, #n, #terms, #words, C_LEFTRECURSIVE[#SortName, #Prec], in after . #[in,after]]
///;

// Pick branching kind.

{$String<!--SortName--> : SortEntry} PG-ProduceBody1[$List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#ND} PG-ProduceBody1[(), #n, #terms, #words, #consumer, in after . #[in,after]]
→
#[%n⟪⟫, EmptyTextMap]
;

{#ND} PG-ProduceBody1[(PFK[RAW-ParsedFormWord[#word, #ParsedForm], #Kind]; #Rest), #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyWord1[#Rest, (), #word, (PFK[#ParsedForm, #Kind];), #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBody1[(PFK[RAW-ParsedFormTerm[#ScopeSort, #Prec, #Repeat, #ParsedForm], #Kind]; #Rest), #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm1[#Rest, (), #ScopeSort, #Prec, #Repeat, #Kind, (PFK[#ParsedForm, #Kind];), #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBody1[(PFK[RAW-ParsedFormSpace[#space, #ParsedForm], #Kind]; #Rest), #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBody1[(PFK[#ParsedForm, #Kind]; #Rest), #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBody1[(PFK[RAW-ParsedFormDone, #Kind]; #Rest), #n, #terms, #words, C_BUFFER[#SortName, #Prec], in after . #[in,after]]
→
{#ND} PG-ProduceBody2[#Rest, #n, #terms, #words, C_BUFFER[#SortName, #Prec], in after . #[in,after],
  PG-AttributeCollection[#Kind, #SortName, #Prec, ProductionConstruction[#SortName, #Prec, #Kind, #words, #terms], B_FALSE],
  PG-AttributeProduction[#Kind, #SortName, #Prec, B_FALSE]]
;

{#ND} PG-ProduceBody1[(PFK[RAW-ParsedFormDone, #Kind]; #Rest), #n, #terms, #words, C_LEFTRECURSIVE[#SortName, #Prec], in after . #[in,after]]
→
{#ND} PG-ProduceBody2[#Rest, #n, #terms, #words, C_LEFTRECURSIVE[#SortName, #Prec], in after . #[in,after],
  PG-AttributeCollection[#Kind, #SortName, #Prec, ProductionConstruction[#SortName, #Prec, #Kind, #words, #terms], B_TRUE],
  PG-AttributeProduction[#Kind, #SortName, #Prec, B_TRUE]]
;

{$String<!--SortName--> : SortEntry} PG-ProduceBody2[$List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text, Text, TextMapSort] :: Text;
-[Data[#in2,#after2]]:
{#ND} PG-ProduceBody2[#Rest, #n, #terms, #words, #consumer, in after . #[in,after], #in2, #after2]
→
{#ND} PG-ProduceBody1[#Rest, #n, #terms, #words, #consumer, in after . #[%n⟪« #in2 »«in»⟫, JoinTextMaps[#after2, after]]]
;

PG-AttributeCollection[FormKind, $String, $Numeric, Text, Boolean] :: Text;

PG-AttributeCollection[#Kind, #SortName, #Prec, #Construct, B_FALSE] → #Construct ;
PG-AttributeCollection[#Kind, #SortName, #Prec, #Construct, B_TRUE] → %n⟪<«ProductionNameWithPrec[#SortName,#Prec]»LR «#Construct»>⟫ ;

PG-AttributeProduction[FormKind, $String, $Numeric, Boolean] :: TextMapSort;
PG-AttributeProduction[#dontcare, #SortName, #Prec, #IsLeftRecursive]
→
EmptyTextMap //TODO: eliminate?
;

ProductionConstruction[$String, $Numeric, FormKind, $List[Text], $List[Text]] :: Text;

-[Data[#SortName,#Prec],Data[#words]]:
ProductionConstruction[#SortName, #Prec, FK_SCHEME[#Inh], #words, #terms]
→
%n⟪⟦ {{ «ProductionNameWithPrec[#SortName, #Prec]»« IfEmpty[#words, %n⟨EMPTY⟩, TextFold1[#words, %n⟨_⟩]] »« WrappedTextFold[#terms, %n⟨[⟩, %n⟨, ⟩, %n⟨]⟩] »}}⟧⟫
;

-[Data[#SortName,#Prec,#Kind],Data[#words]]:
ProductionConstruction[#SortName, #Prec, $[NotMatch,FK_SCHEME[#Inh],#Kind], #words, #terms]
→
IfAliasKind[#Kind, WrappedTextFold[#terms, %n⟨ {{⟩, %n⟨ ⟩, %n⟨}}⟩],
  %n⟪⟦ {{«ProductionNameWithPrec[#SortName, #Prec]»« IfEmpty[#words, %n⟨EMPTY⟩, TextFold1[#words, %n⟨_⟩]] »« WrappedTextFold[#terms, %n⟨[⟩, %n⟨, ⟩, %n⟨]⟩] »}}⟧⟫]
;

∀ a . IfAliasKind[FormKind, a, a] :: a;
IfAliasKind[FK_ALIAS, #1, #2] → #1 ;
IfAliasKind[FK_SYMBOL[#IsStatic], #1, #2] → #1 ;
-[Data[#Kind]]: IfAliasKind[$[NotMatch,FK_ALIAS,$[NotMatch,FK_SYMBOL[#IsStatic],#Kind]], #1, #2] → #2 ;

// (1) Constant Token Case: (a) collect productions starting with the constant token and ...

{$String<!--SortName--> : SortEntry} PG-ProduceBodyWord1[$List[PFK_SORT], $List[PFK_SORT], $String, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#word1,#word],Share[#ParsedForm1,#Kind1,#Rest,#wordPFKs,#n,#terms,#words,#consumer]]:
{#ND} PG-ProduceBodyWord1[(PFK[RAW-ParsedFormWord[#word1, #ParsedForm1], #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
$[If, $[Equal, #word, #word1],
  {#ND} PG-ProduceBodyWord1[#Rest, #Failed, #word, Append[#wordPFKs, (PFK[#ParsedForm1, #Kind1];)], #n, #terms, #words, #consumer, in after . #[in,after]],
  {#ND} PG-ProduceBodyWord1[#Rest, Append[#Failed, (PFK[RAW-ParsedFormWord[#word1, #ParsedForm1], #Kind1];)], #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]]
;

{#ND} PG-ProduceBodyWord1[(PFK[RAW-ParsedFormTerm[#ScopeSort1, #Prec1, #Repeat1, #ParsedForm1], #Kind]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyWord1[#Rest, Append[#Failed, (PFK[RAW-ParsedFormTerm[#ScopeSort1, #Prec1, #Repeat1, #ParsedForm1], #Kind];)], #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyWord1[(PFK[RAW-ParsedFormSpace[#space1, #ParsedForm1], #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyWord1[(PFK[#ParsedForm1, #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyWord1[(PFK[RAW-ParsedFormDone, #Kind]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyWord1[#Rest, Append[#Failed, (PFK[RAW-ParsedFormDone, #Kind];)], #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyWord1[(), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyWord2[#Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

// ... (b) emit constant token branch.

{$String<!--SortName--> : SortEntry} PG-ProduceBodyWord2[$List[PFK_SORT], $String, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#ND} PG-ProduceBodyWord2[(), #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBody[#wordPFKs, #n, #terms, Append[#words, (%n⟨†‹$[Mangle,#word]›⟩;)], #consumer, in1 after1 . #[%n⟪« ProductionWord[#word] »⟦« in1 »⟧⟫, after1]]
;

{#ND} PG-ProduceBodyWord2[(#PFK1;#PFKs), #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBody[#wordPFKs, #n, #terms, Append[#words, (%n⟨†‹$[Mangle,#word]›⟩;)], #consumer, in1 after1 .
  {#ND} PG-ProduceBody[(#PFK1;#PFKs), #n, #terms, #words, #consumer, in2 after2 .
    #[%n⟪(« ProductionWord[#word] »« in1 »
| « in2 »)⟫, JoinTextMaps[after1, after2]]]]
;

ProductionWord[$String] :: Text;
ProductionWord[#word] → %n⟪†« Stringify[#word] »⟫ ;

// (2) Common Nonterminal: (a) collect productions starting with the nonterminal and...

{$String : SortEntry} PG-ProduceBodyTerm1[
	$List[PFK_SORT], $List[PFK_SORT], RawScopeSort, $Numeric, RawRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#ND} PG-ProduceBodyTerm1[(PFK[RAW-ParsedFormWord[#word1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm1[#Rest, Append[#Failed, (PFK[RAW-ParsedFormWord[#word1, #ParsedForm1], #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyTerm1[(PFK[RAW-ParsedFormTerm[#ScopeSort1, #Prec1, #Repeat1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm1x[SameScopeSort[#ScopeSort1, #Prec1, #Repeat1, #ScopeSort, #Prec, #Repeat], #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyTerm1[(PFK[RAW-ParsedFormSpace[#space1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm1[(PFK[#ParsedForm1, #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyTerm1[(PFK[RAW-ParsedFormDone, #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm1[#Rest, Append[#Failed, (PFK[RAW-ParsedFormDone, #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyTerm1[(), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm2[#Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

// ... helper to filter identical scope sorts...

{$String : SortEntry} PG-ProduceBodyTerm1x[Boolean, RawScopeSort, $Numeric, RawRepeat, RawParsedForm, FormKind,
	$List[PFK_SORT], $List[PFK_SORT], RawScopeSort, $Numeric, RawRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#ND} PG-ProduceBodyTerm1x[B_FALSE, #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm1[#Rest, Append[#Failed, (PFK[RAW-ParsedFormTerm[#ScopeSort1, #Prec1, #Repeat1, #ParsedForm1], #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyTerm1x[B_TRUE, #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm1[#Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, Append[#nonterminalPFKs, (PFK[#ParsedForm1, #Kind1];)], #n, #terms, #words, #consumer, in after . #[in,after]]
;

// ... (b) emit branch (with recursive nesting of tail).

{$String : SortEntry} PG-ProduceBodyTerm2[$List[PFK_SORT], RawScopeSort, $Numeric, RawRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#ND} PG-ProduceBodyTerm2[(), #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm3[#ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in, after]]
;

{#ND} PG-ProduceBodyTerm2[(#PFK1;#PFKs), #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm3[#ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in1 after1 .
  {#ND} PG-ProduceBody[(#PFK1;#PFKs), #n, #terms, #words, #consumer, in2 after2 .
    #[%n⟪(« in1 »
| « in2 »)⟫, JoinTextMaps[after1, after2]]]]
;

{$String : SortEntry} PG-ProduceBodyTerm3[RawScopeSort, $Numeric, RawRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#ND} PG-ProduceBodyTerm3[%rawScopeSort⟪ [ #Variable# : #Sort# ] ⟫, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
IfSingletonRepeat[#Repeat,
  {#ND} PG-ProduceBody[#nonterminalPFKs, #n, #terms,  Append[#words, (%n⟨†‹SortVar[#Sort#]›⟩;)], #consumer, in after .
    #[%n⟪⟦ <«ProductionNameWithPrec[SortName[#Sort#], #Prec]»>^†«#Variable#» ⟦« in »⟧ ⟧⟫, after]],
  CookError["Cannot use repeat specification on binder"]]
;

{#ND} PG-ProduceBodyTerm3[%rawScopeSort⟪ #Sort# #Repeat# [ #SubstituteSorts# ] ⟫, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm4[#Sort#, #SubstituteSorts#, ProductionNameWithPrecRepeat[SortName[#Sort#], #Prec, NestedRepeat[#Repeat#, #Repeat]], #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{$String : SortEntry} PG-ProduceBodyTerm4[RawSort, $List[RawSubstituteSort], Text, $Numeric, RawRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

///{#ND} PG-ProduceBodyTerm4[#Sort#, #SubstituteSorts#, #ProductionName, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, C_INLINE, in after . #[in,after]]
///→
///{#ND} PG-ProduceBody[#nonterminalPFKs, #n, #terms, #words, C_INLINE, in after .
///  #[%n⟪⟦<« #ProductionName »>« WrappedTextFold[Map[s.ExtractSubstitutedSort[s], #SubstituteSorts#], %n⟨[⟩, %n⟨,⟩, %n⟨]⟩] »« VariableMarker[#Kind, %n⟨⟩] » ⟦« in »⟧ ⟧⟫, after]]
///;

-[Data[#consumer]]:
{#ND} PG-ProduceBodyTerm4[#Sort#, #SubstituteSorts#, #ProductionName, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, <!--$[NotMatch,C_INLINE,-->#consumer<!--]-->, in after . #[in,after]]
→
{#ND} PG-ProduceBody[#nonterminalPFKs, $[Plus,#n,1],
  Append[#terms, (%n⟨†‹ SortMetaVar[#Sort#, #n] ›⟩;)],
  Append[#words, (%n⟨†‹ SortName[#Sort#] ›⟩;)],
  #consumer,
  in after .
    #[%n⟪⟦ <« #ProductionName »>«
           WrappedTextFold[Map[s.ExtractSubstitutedSort[s], #SubstituteSorts#], %n⟨[⟩, %n⟨,⟩, %n⟨]⟩]
	     »« VariableMarker[#Kind, %n⟨:†‹ SortMetaVar[#Sort#, #n] ›⟩] » ⟦« in »⟧ ⟧⟫,after]]
;

// TODO: Eliminate redundant repeat productions!

ExtractSubstitutedSort[RawSubstituteSort] :: Text;
ExtractSubstitutedSort[%rawSubstituteSort⟪ #Variable1# : #Sort2# ⟫] → %n⟪†«#Variable1#»⟫ ;

VariableMarker[FormKind, Text] :: Text;
-[Data[#Kind]]: VariableMarker[#Kind, #Other] → VariableMarker2[#Kind, #Other] ;

VariableMarker2[FormKind, Text] :: Text;
VariableMarker2[FK_SYMBOL[$False], #Other] → %n⟪!!!« #Other »⟫ ;
VariableMarker2[FK_SYMBOL[$True], #Other] → %n⟪!!« #Other »⟫ ;
VariableMarker2[$[NotMatch,FK_SYMBOL[#IsStatic],#Kind], #Other] → #Other ;

// HAND-CODED HACK to recognize and strip left recursive production (because Raw.pg cannot match parsed forms...). 

PG-isLeftRecursive[$String, $Numeric, PFK_SORT] :: Boolean;

PG-isLeftRecursive[#SortName, #Prec, PFK[RAW-ParsedFormSpace[#Space, #ParsedForm1], #Kind]]
→
PG-isLeftRecursive[#SortName, #Prec, PFK[#ParsedForm1, #Kind]]
;

PG-isLeftRecursive[#SortName, #Prec, PFK[RAW-ParsedFormWord[#Word, #ParsedForm1], #Kind]]
→
B_FALSE
;

-[Data[#Sort]]:
PG-isLeftRecursive[#SortName, #Prec, PFK[RAW-ParsedFormTerm[#Sort1, #Prec1, #Repeat1, #ParsedForm1], #Kind]]
→
$[If, $[NumericEqual,#Prec,#Prec1], PG-isLeftRecursive1[#SortName, #Sort1], B_FALSE]
;

PG-isLeftRecursive[#SortName, #Prec, PFK[RAW-ParsedFormDone, #Kind]]
→
B_FALSE
;

PG-isLeftRecursive1[$String, RawScopeSort] :: Boolean;

PG-isLeftRecursive1[#SortName,
  RAW-ScopeSort[
    RAW-Sort[RAW-SortName[#SortName1, #_1], '$Nil'],
    RAW-RepeatSingle,
    '$Nil']]
→
SameString[#SortName,#SortName1]
;

-[Data[#Kind]]:
PG-isLeftRecursive1[#SortName, $[NotMatch,
  RAW-ScopeSort[
    RAW-Sort[RAW-SortName[#SortName1, #_1], '$Nil'],
    RAW-RepeatSingle,
    '$Nil'],#_]]
→
B_FALSE
;

PG-stripLeftRecursion[PFK_SORT] :: PFK_SORT;
PG-stripLeftRecursion[PFK[RAW-ParsedFormSpace[#Space, #ParsedForm1], #Kind]]
→
PG-stripLeftRecursion[PFK[#ParsedForm1, #Kind]]
;
PG-stripLeftRecursion[
  PFK[
    RAW-ParsedFormTerm[
      RAW-ScopeSort[
        RAW-Sort[RAW-SortName[#SortName, #_], '$Nil'],
        RAW-RepeatSingle,
        '$Nil'],
      #Prec,
      #Repeat,
	  #ParsedForm],
    #Kind]]
→
PFK[#ParsedForm, #Kind]
;

/////////////////////////////////////////////////////////////////////
// Test if two ScopeSorts are the same.

SameScopeSort[RawScopeSort, $Numeric, RawRepeat, RawScopeSort, $Numeric, RawRepeat] :: Boolean;
SameScopeSort[#Sort1, #Prec1, #Repeat1, #Sort2, #Prec2, #Repeat2] → SameScopeSort2[#Sort1, #Sort2, #Prec1, #Repeat1, #Prec2, #Repeat2] ;

SameScopeSort2[RawScopeSort, RawScopeSort, $Numeric, RawRepeat, $Numeric, RawRepeat] :: Boolean;

SameScopeSort2[%rawScopeSort⟪ #Sort1# [ #SubstituteSorts1# ] ⟫, %rawScopeSort⟪ #Sort2# [ #SubstituteSorts2# ] ⟫, #Prec1, #Repeat1, #Prec2, #Repeat2]
→
And[SameSort[#Sort1#, #Sort2#], And[SamePrec[#Prec1, #Prec2], SubRepeat[#Repeat1, #Repeat2]]]
;
SameScopeSort2[%rawScopeSort⟪ [ #Variable1# : #Sort1# ] ⟫                   , %rawScopeSort⟪ #Sort2# [ #SubstituteSorts2# ] ⟫, #P1, #R1, #P2, #R2] → B_FALSE ;
SameScopeSort2[%rawScopeSort⟪ #Sort1# [ #SubstituteSorts1# ] ⟫, %rawScopeSort⟪ [ #Variable2# : #Sort2# ] ⟫, #P1, #R1, #P2, #R2] → B_FALSE ;
SameScopeSort2[%rawScopeSort⟪ [ #Variable1# : #Sort1# ] ⟫                   , %rawScopeSort⟪ [ #Variable2# : #Sort2# ] ⟫, #P1, #R1, #P2, #R2] → SameSort[#Sort1#, #Sort2#] ;

SameSort[RawSort, RawSort] :: Boolean;
-[Data[#1,#2]]: SameSort[#1, #2] → SameSort2[#1, #2] ;

SameSort2[RawSort, RawSort] :: Boolean;

-[Data[#SortName1#,#SortName2#]]:
SameSort2[%rawSort⟪ #SortName1# #MetaVariables1# #SimpleSorts1# ⟫, %rawSort⟪ #SortName2# #MetaVariables2# #SimpleSorts2# ⟫]
→
$[If, $[Equal, #SortName1#, #SortName2#], B_TRUE, B_FALSE]
;

SameSort2[$[NotMatch,%rawSort⟪ #SortName1# #MetaVariables1# #SimpleSorts1# ⟫,#1], #2]
→
B_FALSE
;

SameSort2[#1,$[NotMatch,%rawSort⟪ #SortName2# #MetaVariables2# #SimpleSorts2# ⟫,#2]]
→
B_FALSE
;

SamePrec[$Numeric, $Numeric] :: Boolean;
-[Data[#Prec1,#Prec2]]: SamePrec[#Prec1, #Prec2] → $[If, $[NumericEqual, #Prec1, #Prec2], B_TRUE, B_FALSE] ;

SubRepeat[RawRepeat, RawRepeat] :: Boolean;

SubRepeat-single: SubRepeat[%rawRepeat⟪ ⟫, #Repeat2] → B_TRUE ;

SubRepeat-maybe-single: SubRepeat[%rawRepeat⟪ ? ⟫, %rawRepeat⟪ ⟫] → B_FALSE;
SubRepeat-maybe-maybe: SubRepeat[%rawRepeat⟪ ? ⟫, %rawRepeat⟪ ? ⟫] → B_TRUE;
SubRepeat-maybe-many: SubRepeat[%rawRepeat⟪ ? ⟫, %rawRepeat⟪ * ⟫] → B_TRUE;
SubRepeat-maybe-some: SubRepeat[%rawRepeat⟪ ? ⟫, %rawRepeat⟪ + ⟫] → B_FALSE;
SubRepeat-maybe-somesep: SubRepeat[%rawRepeat⟪ ? ⟫, %rawRepeat⟪ + _ #RegExpLeaf2# ⟫] → B_FALSE;

SubRepeat-some-single: SubRepeat[%rawRepeat⟪ + ⟫, %rawRepeat⟪ ⟫] → B_FALSE;
SubRepeat-some-maybe: SubRepeat[%rawRepeat⟪ + ⟫, %rawRepeat⟪ ? ⟫] → B_FALSE;
SubRepeat-some-many: SubRepeat[%rawRepeat⟪ + ⟫, %rawRepeat⟪ * ⟫] → B_TRUE;
SubRepeat-some-some: SubRepeat[%rawRepeat⟪ + ⟫, %rawRepeat⟪ + ⟫] → B_TRUE;
SubRepeat-some-somesep: SubRepeat[%rawRepeat⟪ + ⟫, %rawRepeat⟪ + _ #RegExpLeaf2# ⟫] → B_FALSE;

SubRepeat-many-many: SubRepeat[%rawRepeat⟪ * ⟫, %rawRepeat⟪ * ⟫] → B_TRUE ;
SubRepeat-many-other[Data[#_]]: SubRepeat[%rawRepeat⟪ * ⟫, $[NotMatch,%rawRepeat⟪ * ⟫,#_]] → B_FALSE;

SubRepeat-somesep-single: SubRepeat[%rawRepeat⟪ + _ #RegExpLeaf1# ⟫, %rawRepeat⟪ ⟫] → B_FALSE;
SubRepeat-somesep-maybe: SubRepeat[%rawRepeat⟪ + _ #RegExpLeaf1# ⟫, %rawRepeat⟪ ? ⟫] → B_FALSE;
SubRepeat-somesep-many: SubRepeat[%rawRepeat⟪ + _ #RegExpLeaf1# ⟫, %rawRepeat⟪ * ⟫] → B_FALSE;
SubRepeat-somesep-some: SubRepeat[%rawRepeat⟪ + _ #RegExpLeaf1# ⟫, %rawRepeat⟪ + ⟫] → B_FALSE;

SubRepeat-somesep-string-string: SubRepeat[%rawRepeat⟪ + _ #String1# ⟫, %rawRepeat⟪ + _ #String2# ⟫] → SameString[UnString[#String1#], UnString[#String2#]] ;
SubRepeat-somesep-string-word: SubRepeat[%rawRepeat⟪ + _ #String1# ⟫, %rawRepeat⟪ + _ #Word2# ⟫] → SameString[UnString[#String1#], #Word2#] ;
SubRepeat-somesep-word-string: SubRepeat[%rawRepeat⟪ + _ #Word1# ⟫, %rawRepeat⟪ + _ #String2# ⟫] → SameString[#Word1#, UnString[#String2#]] ;
SubRepeat-somesep-word-word: SubRepeat[%rawRepeat⟪ + _ #Word1# ⟫, %rawRepeat⟪ + _ #Word2# ⟫] → SameString[#Word1#, #Word2#] ;


/////////////////////////////////////////////////////////////////////
// TEXT LIST OF REPEAT-DERIVED DECLARATIONS.

PG-ProduceDerived[DERIVED_SORT] :: TextMapSort;
PG-ProduceDerived[DERIVED[#SortName, #Prec, #Repeat]] → PG-ProduceRepeat[#Repeat, #SortName, #Prec, ProductionNameWithPrecRepeat[#SortName, #Prec, #Repeat]] ; 


PG-ProduceRepeat[RawRepeat, $String, $Numeric, Text] :: TextMapSort;

PG-ProduceRepeat[%rawRepeat⟪ ⟫, #s, #p, #name] → EmptyTextMap ;

-[Data[#s]]:
PG-ProduceRepeat[%rawRepeat⟪ ? ⟫, #s, #p, #name]
→
SingletonTextMap[TextToString[#name], %n⟪
<«#name»> ::= «
  PG-MetaHead[B_TRUE, $[:,#s,"?"], TextToString[#name], B_FALSE, 0]
»( <«ProductionNameWithPrec[#s, #p]»>:#1 {{ $Cons[#1,$Nil] }} | {{ $Nil }} ).
« PG-MetaTail[B_TRUE, $[:,#s,"?"], TextToString[#name]] »⟫]
;

-[Data[#s]]:
PG-ProduceRepeat[%rawRepeat⟪ * ⟫, #s, #p, #name]
→
SingletonTextMap[TextToString[#name], %n⟪
<«#name»> ::= «
  PG-MetaHead[B_TRUE, $[:,#s,"*"], TextToString[#name], B_FALSE, 0]
»( <«ProductionNameWithPrec[#s, #p]»>:#1 <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Nil }} ).
« PG-MetaTail[B_TRUE, $[:,#s,"*"], TextToString[#name]] »⟫]
;

-[Data[#s]]:
PG-ProduceRepeat[%rawRepeat⟪ + ⟫, #s, #p, #name]
→
SingletonTextMap[TextToString[#name], %n⟪
<«#name»> ::= «
  PG-MetaHead[B_TRUE, $[:,#s,"+"], TextToString[#name], B_FALSE, 0]
» <«ProductionNameWithPrec[#s, #p]»>:#1 ( <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Cons[#1,$Nil] }} ) .
« PG-MetaTail[B_TRUE, $[:,#s,"+"], TextToString[#name]] »⟫]
;

-[Data[#s]]:
PG-ProduceRepeat[%rawRepeat⟪ + _ #RegExpLeaf# ⟫, #s, #p, #name]
→
SingletonTextMap[TextToString[#name], %n⟪
<«#name»> ::= «
  PG-MetaHead[B_TRUE, RegExpLeafSuffix[#RegExpLeaf#, $[:,#s,"+_"]], TextToString[#name], B_FALSE, 0]
» <«ProductionNameWithPrec[#s, #p]»>:#1 ( « PG-InlineRegExpSimple[#RegExpLeaf#, ""] » <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Cons[#1,$Nil] }} ) .
« PG-MetaTail[B_TRUE, RegExpLeafSuffix[#RegExpLeaf#, $[:,#s,"+_"]], TextToString[#name]] »⟫]
;


/////////////////////////////////////////////////////////////////////
// TEXT LIST OF LEXICAL DECLARATIONS.

PG-Lexical[RawDeclarations] :: Text ;
PG-Lexical[#Declarations] → PG-Lexical2[#Declarations, B_FALSE, hasskip.PG-Lexical2Tail[hasskip]] ;

PG-Lexical2[RawDeclarations, Boolean, ha::Boolean.Text] :: Text ;

Lexical-module:
PG-Lexical2[%rawDeclarations⟪ module #ModuleName2# { #Declarations2# } ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations2#, #hasSkip, hasskip.PG-Lexical2[#Declarations#, hasskip, hasskip2.#[hasskip2]]]
;

Lexical-space:
PG-Lexical2[%rawDeclarations⟪ space #RegExp# ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
%n⟪skip ::= ' ' | ⟦« PG-InlineRegExp[#RegExp#, "space$"] »⟧ .
« PG-DeclareRegExp[#RegExp#, "space$"] »« PG-Lexical2[#Declarations#, B_TRUE, hasskip.#[hasskip]] »⟫
;

Lexical-token:
PG-Lexical2[%rawDeclarations⟪ token #SortName# | #RegExp# ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
%n⟪token «TokenName[#SortName#]» ::= ⟦« PG-InlineRegExp[#RegExp#, #SortName#] »⟧ .
« PG-DeclareRegExp[#RegExp#, #SortName#] »« PG-Lexical2[#Declarations#, #hasSkip, hasskip.#[hasskip]] »⟫
;

Lexical-fragment:
PG-Lexical2[%rawDeclarations⟪ fragment #FragmentName# | #RegExp# ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
%n⟪token fragment «TokenName[#FragmentName#]» ::= ⟦« PG-InlineRegExp[#RegExp#, #FragmentName#] »⟧ . 
« PG-DeclareRegExp[#RegExp#, #FragmentName#] »« PG-Lexical2[#Declarations#, #hasSkip, hasskip.#[hasskip]] »⟫
;

Lexical-attribute:
PG-Lexical2[%rawDeclarations⟪ attribute #AttributeKind# #AttributeName# #AttributeForm# #AttributeOptions# ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations#, #hasSkip, hasskip.#[hasskip]]
;

Lexical-sort:
PG-Lexical2[%rawDeclarations⟪ sort #SortName# #Repeat# #SortAbstraction# ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations#, #hasSkip, hasskip.#[hasskip]]
;

Lexical-alternatives:
PG-Lexical2[%rawDeclarations⟪ #SortAlternatives# ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations#, #hasSkip, hasskip.#[hasskip]]
;

Lexical-rule:
PG-Lexical2[%rawDeclarations⟪ rule #Rule# ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations#, #hasSkip, hasskip.#[hasskip]]
;

Lexical-nest:
PG-Lexical2[%rawDeclarations⟪ { #Declarations2# } #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations2#, #hasSkip, hasskip.PG-Lexical2[#Declarations#, hasskip, hasskip2.#[hasskip2]]]
;

Lexcial-done:
PG-Lexical2[%rawDeclarations⟪ ⟫, #hasSkip, hasskip.#[hasskip]]
→
#[#hasSkip]
;

PG-Lexical2Tail[Boolean] :: Text;
PG-Lexical2Tail[B_TRUE] → %n⟪⟫ ;
PG-Lexical2Tail[B_FALSE] → %n⟪skip ::= " " .
⟫ ;


/////////////////////////////////////////////////////////////////////
// INLINE TEXT OF REGULAR EXPRESSION.

PG-InlineRegExp[RawRegExp, $String<!--identifier-->] :: Text ;
PG-InlineRegExp[%rawRegExp⟪ #RegExpChoice# | #RegExp# ⟫, #id]
→
%n⟪⟦« PG-InlineRegExpChoice[#RegExpChoice#, #id] »⟧ « PG-InlineRegExp2[#RegExp#, #id] »⟫
;
PG-InlineRegExp2[RawRegExp, $String<!--identifier-->] :: Text ;
PG-InlineRegExp2[%rawRegExp⟪ #RegExpChoice# | #RegExp# ⟫, #id]
→
%n⟪| ⟦« PG-InlineRegExpChoice[#RegExpChoice#, #id] »⟧ « PG-InlineRegExp2[#RegExp#, #id] »⟫
;
PG-InlineRegExp2['RegExp$Nil', #id]
→
%n⟪⟫
;

PG-InlineRegExpChoice[RawRegExpChoice, $String] :: Text;

PG-InlineRegExpChoice[%rawRegExpChoice⟪ nested #RegExpSimple1# #RegExpSimple2# ⟫, #id]
→
%n⟪NESTED_«TokenName[#id]»⟫
;
PG-InlineRegExpChoice[%rawRegExpChoice⟪ #RegExpUnits# ⟫, #id]
→
PG-InlineRegExpUnits[#RegExpUnits#, #id]
;

PG-InlineRegExpUnits[$List[RawRegExpUnit], $String] :: Text;

PG-InlineRegExpUnits[%rawRegExpUnits⟪ #RegExpUnit# #RegExpUnits# ⟫, #id]
→
%n⟪« PG-InlineRegExpUnit[#RegExpUnit#, #id] » « PG-InlineRegExpUnits[#RegExpUnits#, #id] »⟫
;
PG-InlineRegExpUnits[%rawRegExpUnits⟪ ⟫, #id]
→
%n⟪⟫
;

PG-InlineRegExpUnit[RawRegExpUnit, $String] :: Text;

PG-InlineRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# ⟫, #id]
→
PG-InlineRegExpSimple[#RegExpSimple#, #id]
;

PG-InlineRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# ? ⟫, #id]
→
%n⟪( « PG-InlineRegExpSimple[#RegExpSimple#, #id] » )?⟫
;

PG-InlineRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# * ⟫, #id]
→
%n⟪( « PG-InlineRegExpSimple[#RegExpSimple#, #id] » )*⟫
;

PG-InlineRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# + ⟫, #id]
→
%n⟪( « PG-InlineRegExpSimple[#RegExpSimple#, #id] » )+⟫
;

PG-InlineRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# + _ #RegExpLeaf# ⟫, #id]
→
%n⟪( « PG-InlineRegExpSimple[#RegExpSimple#, #id] » ( « PG-InlineRegExpSimple[#RegExpLeaf#, #id] » « PG-InlineRegExpSimple[#RegExpSimple#, #id] » )* )⟫
;

PG-InlineRegExpSimple[RawRegExpSimple, $String] :: Text;

PG-InlineRegExpSimple[%rawRegExpSimple⟪ #String# ⟫, #id]
→
%n⟪†«#String#»⟫ // TODO: manually process (here and above)!
;

PG-InlineRegExpSimple[%rawRegExpSimple⟪ #Word# ⟫, #id]
→
%n⟪†« Stringify[#Word#] »⟫ // TODO: manually process (here and above)!
;

PG-InlineRegExpSimple[%rawRegExpSimple⟪ #FragmentRef# ⟫, #id]
→
%n⟪«TokenName[#FragmentRef#]»⟫
;

PG-InlineRegExpSimple[%rawRegExpSimple⟪ . ⟫, #id]
→
PG-InlineRegExpSimple[%rawRegExpSimple⟪ [^\n\r\f] ⟫, #id]
;

PG-InlineRegExpSimple[%rawRegExpSimple⟪ #RegExpClass# ⟫, #id]
→
PG-InlineRegExpClass1[#RegExpClass#, #id]
;

PG-InlineRegExpSimple[%rawRegExpSimple⟪ ( #RegExp# ) ⟫, #id]
→
%n⟪( « PG-InlineRegExp[#RegExp#, #id] » )⟫
;

PG-InlineRegExpClass1[RawRegExpClass, $String] :: Text;

PG-InlineRegExpClass1[RAW-RegExpClassNot[#RegExpClass], #id]
→
%n⟪~[« PG-InlineRegExpClass2[#RegExpClass, #id, %n⟨⟩] »]⟫
;

PG-InlineRegExpClass1[$[NotMatch,RAW-RegExpClassNot[#_],#RegExpClass], #id]
→
%n⟪[« PG-InlineRegExpClass2[#RegExpClass, #id, %n⟨⟩] »]⟫
;

PG-InlineRegExpClass2[RawRegExpClass, $String, Text] :: Text;

PG-InlineRegExpClass2[RAW-RegExpClassChar[#Char, #RegExpClass], #id, #sep]
→
%n⟪«#sep»« PG-InlineRegExpRangeChar[#Char, #id] »« PG-InlineRegExpClass2[#RegExpClass, #id, %n⟨,⟩] »⟫
;

PG-InlineRegExpClass2[RAW-RegExpClassRange[#lo, #hi, #RegExpClass], #id, #sep]
→
%n⟪«#sep»« PG-InlineRegExpRangeChar[#lo, #id] »-« PG-InlineRegExpRangeChar[#hi, #id] »« PG-InlineRegExpClass2[#RegExpClass, #id, %n⟨,⟩] »⟫
;

PG-InlineRegExpClass2[RAW-RegExpClassDone, #id, #sep]
→
%n⟪⟫
;
PG-InlineRegExpRangeChar[$String, $String] :: Text;
-[Data[#RegExpRangeStartChar#]]:
PG-InlineRegExpRangeChar[#RegExpRangeStartChar#, #id]
→
$[If, $[Equal,#RegExpRangeStartChar#,"'"], %n⟪"'"⟫, %n⟪'†« #RegExpRangeStartChar# »'⟫]
;


/////////////////////////////////////////////////////////////////////
// RESIDUAL DECLARATIONS FROM REGULAR EXPRESSION.

PG-DeclareRegExp[RawRegExp, $String<!--identifier-->] :: Text ;
PG-DeclareRegExp[%rawRegExp⟪ #RegExpChoice# | #RegExp# ⟫, #id]
→
%n⟪« PG-DeclareRegExpChoice[#RegExpChoice#, #id] »« PG-DeclareRegExp[#RegExp#, #id] »⟫
;
PG-DeclareRegExp['RegExp$Nil', #id]
→
%n⟪⟫
;

PG-DeclareRegExpChoice[RawRegExpChoice, $String] :: Text;
PG-DeclareRegExpChoice[%rawRegExpChoice⟪ nested #RegExpSimple1# #RegExpSimple2# ⟫, #id]
→
%n⟪
%{
/* token †«#id». */
MORE : { < « PG-InlineRegExpSimple[#RegExpSimple1#, #id] » > { nested_counter = 0; } : IN_«TokenName[#id]» }
<IN_«TokenName[#id]»,IN_NESTED_«TokenName[#id]»> MORE : { < « PG-InlineRegExpSimple[#RegExpSimple1#, #id] » > { nested_counter++; } : IN_NESTED_«TokenName[#id]» }
<IN_NESTED_«TokenName[#id]»> MORE : { < « PG-InlineRegExpSimple[#RegExpSimple2#, #id] » > { if (--nested_counter <= 0) SwitchTo(IN_«TokenName[#id]»); } }
<IN_«TokenName[#id]»> †« $[If,$[Equal,#id,"space$"],"SKIP","TOKEN"] » : { < T_NESTED_«TokenName[#id]» : « PG-InlineRegExpSimple[#RegExpSimple2#, #id] » > : DEFAULT }
<IN_«TokenName[#id]»,IN_NESTED_«TokenName[#id]»> MORE : { < ~[] > }
%}
⟫
;
PG-DeclareRegExpChoice[%rawRegExpChoice⟪ #RegExpUnits# ⟫, #id]
→
PG-DeclareRegExpUnits[#RegExpUnits#, #id]
;

PG-DeclareRegExpUnits[$List[RawRegExpUnit], $String] :: Text;
PG-DeclareRegExpUnits[%rawRegExpUnits⟪ #RegExpUnit# #RegExpUnits# ⟫, #id]
→
%n⟪« PG-DeclareRegExpUnit[#RegExpUnit#, #id] »« PG-DeclareRegExpUnits[#RegExpUnits#, #id] »⟫
;
PG-DeclareRegExpUnits[%rawRegExpUnits⟪ ⟫, #id]
→
%n⟪⟫
;

PG-DeclareRegExpUnit[RawRegExpUnit, $String] :: Text;
PG-DeclareRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# ⟫, #id] → PG-DeclareRegExpSimple[#RegExpSimple#, #id] ;
PG-DeclareRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# ? ⟫, #id] → PG-DeclareRegExpSimple[#RegExpSimple#, #id] ;
PG-DeclareRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# * ⟫, #id] → PG-DeclareRegExpSimple[#RegExpSimple#, #id] ;
PG-DeclareRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# + ⟫, #id] → PG-DeclareRegExpSimple[#RegExpSimple#, #id] ;
PG-DeclareRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# + _ #RegExpLeaf# ⟫, #id] → %n⟪« PG-DeclareRegExpSimple[#RegExpSimple#, #id] »« PG-DeclareRegExpSimple[#RegExpLeaf#, #id] »⟫ ;

PG-DeclareRegExpSimple[RawRegExpSimple, $String] :: Text;
PG-DeclareRegExpSimple[%rawRegExpSimple⟪ #String# ⟫, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawRegExpSimple⟪ #Word# ⟫, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawRegExpSimple⟪ #FragmentRef# ⟫, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawRegExpSimple⟪ . ⟫, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawRegExpSimple⟪ #RegExpClass# ⟫, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawRegExpSimple⟪ ( #RegExp# ) ⟫, #id] → PG-DeclareRegExp[#RegExp#, #id] ;

)]
